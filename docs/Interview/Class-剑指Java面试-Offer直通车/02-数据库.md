# 一、架构

## 如何设计一个关系型数据库？

> 设计一个数据库就跟设计一款软件差不多，也是将其分界成很多模块，面试官问这个也主要是想考查我们的模块划分能力以及对数据库的了解。记忆一个东西的最佳方式便是站在设计者的角度去设计它。

![image-20210817002508406](https://z3.ax1x.com/2021/08/17/fhpWtg.png)

**答：**要设计一个关系型数据库，首相要将其划分成两大部分。一个是存储部分，该部分类似一个文件系统，来将数据持久化到存储设备中。还需要一个程序实例模块，来对存储进行逻辑上的管理。而程序实例模块将包含：

- 将数据的逻辑关系转换成物理储存的存储管理模块
- 优化执行效率的缓存模块
- 将 SQL 语句进行解析的 SQL 解析模块
- 记录操作的日志管理模块
- 进行多用户管理的权限划分模块
- 灾难恢复模块
- 优化数据查询效率的索引模块
- 使数据库支持并发操作的锁模块

# 二、索引

## 为什么要使用索引？

要回答这个问题，咱们先来对数据的查询方式做个调研，先试试最简单的查询方式，即全表扫描。它是将整张表的内容全部或分批次加载到内存中。MySQL 存储的最小单位是块或者页，它们是由多行数据组成的，然后我们将这些块都加载进来，然后逐个块去轮询，找到我们要的目标并返回。这种方式普遍被认为是非常的慢的。

全表扫描在所有的情况下都这么慢吗？存在即合理，它也有很适用的地方，当只有很少量的数据，全部加载到内存里进行全表扫描要比后面说的使用索引的方式要快。当然如果在数据量大的情况下，这种方式显然不适用了。因此这里就引出了我们的答案，很多情况下，我们都需要避免全表扫描的情况发生，索引数据库要引入一种更高效的机制，这便是索引。

索引的灵感来自于字典，依据字母很快就能定位到要查找的内容。而这些定位数据的关键信息便组成了索引，通过索引来大幅提升查询的速度便是问题的答案。但是仅仅这么回答不能让面试官满意，还需要结合后面的内容。

## 什么样的信息能成为索引？

能把数据记录限定在一定查找范围内的字段，主键便是一个很好的切入点，还有唯一键及普通键等。

## 索引的数据结构？

索引数据结构的选择，有以下几种方案

- 生成索引，建立二又查找树进行二分查找
- 生成索引，建立B-Tree结构进行查找
- 生成索引，建立B+-Tree结构进行查找
- 生成索引，建立Hash结构进行查找

接下来我们将各种数据结构用在索引上，一体现其优势和劣势，之后再更为详细地回答问题。

**二叉查找树上阵**

如下图左边所示，模拟使用二叉查找树来生成索引，每个节点存储一个数据和两个指针。二叉查找树使用二分查找查询数据，确实能够提高查询效率，时间复杂度是 O(logN)。但是当数据增加或者删除的时候，例如删除节点 2 和 6 的数据，增加节点 13，二叉树就变成了下图右所示，此时查询的时间复杂度变成了 O(N)，大大降低了查询效率。

![image-20210817013002079](https://z3.ax1x.com/2021/08/17/fhpRAS.png)

有同学可能会说使用树的旋转保证二叉树平衡，就可以维持查询复杂度为 O(logN)。这样确实解决了第一个问题，但是还会有第二个问题。二叉树或者红黑树只能有两个孩子，因此为了组织数据块，索引树的深度就会很深，查询一个数据的查找深度也会很深，影响查询效率。

**B 树**

B 树是一种多路查找树，如果每一个节点最多有 m 个孩子，这样 B 树就是 m 阶 B 树。下图就是一个三阶 B 树。

 ![image-20210817014058573](https://z3.ax1x.com/2021/08/17/fhpg78.png)

对于一个 m 阶 B 树，有以下特征：

- 根节点至少包括两个孩子
- 树中每个节点最多含有 m 个孩子（m>=2）
- 除根节点和叶节点外，其他每个节点至少有 ceil(m/2) 个孩子（ceil 向上取整）
- 所有叶子节点都位于同一层

与其说是特征，不如说是 B 树必须遵守的一个约定，目的就是让每个索引节点存储尽可能多的信息，尽可能减少树的高度，减小查找深度。

最后 B 树还有以下特征：

![image-20210817015343873](https://z3.ax1x.com/2021/08/17/fh9Sj1.png)

以搜索元素 15 为例，讲述 B 树查找元素过程：首先找根节点 `node1(17, 35)`，15 < 17，所以找 17 左边的指针 P1 指向的节点  `node2(8, 12)`，15 > 12，找 12 右边指针 P3 指向的节点 `node3(13, 15)`，至此找到了元素 15。

B 树的查找效率同样是 O(logN)，B 树中增加删除节点时，有其相应的策略，通过合并分裂上一下一节点来维持其特性，让其始终平衡。

**B+ 树**

B+ 树是 B 树的变体，其定义基本与 B 树相同，除了：

- 非叶子节点的子树指针与关键字个数相同
- 非叶子节点的子树指针 `P[i]`，指向关键字值 `[ K[i], K[i+1] )` 的子树
- 非叶子节点仅用来索引，数据都保存在叶子节点中
- 所有叶子节点均有一个链指针指向下一个叶子结点

![image-20210817020915150](https://z3.ax1x.com/2021/08/17/fh91US.png)

> 非叶子节点不存储数据，这样就可以存更多的关键字了，这就使得 B+ 树相对于 B 树来说更矮。B+ 树所有叶子节点链接起来，使得其支持范围查找。

为什么 B+Tree 更适合用来做存储索引：

1. B+ 树的磁盘读写代价更低
2. B+ 树的查询效率更加稳定
3. B+ 树更有利于对数据库的扫描

**Hash 索引也可以考虑以下**

Hash 索引使用 Hash 函数的运算，只需一次就能定位数据所在的头。

![image-20210817022608488](https://z3.ax1x.com/2021/08/17/fh9sC4.png)

缺点：

- 仅仅能满足 “="，“IN"，不能使用范围查询
- 无法被用来避免数据的排序操作
- 不能利用部分索引键查询
- 不能避免表扫描
- 遇到大量 Hash 值相等的情况后性能并不一定就会比 B-Tree 索引高

**BitMap 索引是个神奇**

目前很少有数据库都支持位图索引，比较主流的是 Oracle。

![image-20210817022802418](https://z3.ax1x.com/2021/08/17/fh9629.png)

## 密集索引和稀疏索引的区别？

- 密集索引文件中的每个搜索码值都对应一个索引值
- 稀疏索引文件只为索引码的某些值建立索引项

# 三、锁

# 四、语法

# 五、理论范式