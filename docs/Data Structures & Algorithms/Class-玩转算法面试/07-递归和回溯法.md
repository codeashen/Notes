# 树形问题（电话号码的字母组合）

上一章中，我们介绍了二叉树相关问题，通常需要使用递归算法，这一章我们来看一下更多递归的应用，以及使用递归算法时一个非常经典的思想——**回溯法**，这个思想通常都应用在一类问题上，我们称作树形问题。这类问题本身没有定义在二叉树机构中，但是当我们具体分析后，会发现解决这个问题的思路本质是一棵树的形状。

这一节我们先从一个比较简单的问题入手。

## 问题分析

> [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)
>
> 给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt="img" style="zoom: 33%;" />
>
> ```
> 输入：digits = "23" 
> 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
> ```

如下图所示，我们以 `digits = "23"` 为例，先来看 `2` 可以代表 `(a, b , c)` 三个字母，所以我们就需要基于 `(a, b , c)` 这三种可能来考虑下一个数字 `3` 能代表哪些字母，`3` 能代表 `(d, e, f)` 三个字母，所以我们就得到了 `3 * 3 = 9` 种字母组合 `["ad","ae","af","bd","be","bf","cd","ce","cf"]`。

![image-20210902153448426](https://z3.ax1x.com/2021/09/02/hrNo24.png)

经过分析，我们看到形成了一棵树，这类问题的思路是隐藏在一颗树种的，所以我们把这类问题称为树形问题。因为是树形结构，所以我们很容易想到使用递归的方式来解决，这个问题的递归结构在哪里呢？

我们从 `2` 开始看可以表示哪些字母，我们只需要求出 `3` 能代表哪些字母，然后在前面加上 `2` 所能代表的这些字母，一起就构成了结果。



```java
/**
 * 时间复杂度: O(3^m * 4^n)，m 为可以代表 3 个字母的数字个数，n 为可以代表 4 个字母的数字个数
 * 空间复杂度: O(m + n)，m+n 为输入数字的总个数
 */
class Solution {
    // 每个数字对应的字母，0 和 1 在本题中不用
    private String[] letterMap = {
        " ",    // 0
        "",     // 1
        "abc",  // 2
        "def",  // 3
        "ghi",  // 4
        "jkl",  // 5
        "mno",  // 6
        "pqrs", // 7
        "tuv",  // 8
        "wxyz"  // 9
    };

    // 存放结果
    private List<String> res;

    public List<String> letterCombinations(String digits) {
        res = new ArrayList<>();
        if (digits.equals(""))
            return res;
        findCombination(digits, 0, "");
        return res;
    }

    /**
     * 翻译 digits 字符串 index 索引下的字符，拼接到字符串 s 上，然后添加到结果 res 中
     *
     * @param digits 数字字符串
     * @param index  将要翻译的索引
     * @param str    到目前位置翻译的结果，当翻译到 digits 最后一位时将其添加到 res 中
     */
    private void findCombination(String digits, int index, String str) {
        if (index == digits.length()) {
            res.add(str);
            return;
        }

        String letters = letterMap[digits.charAt(index) - '0'];
        for (int i = 0; i < letters.length(); i++)
            findCombination(digits, index + 1, str + letters.charAt(i));
    }
}
```

# 什么是回溯

## 回溯法介绍

下面我们结合图示来解释上一节题目对应程序的运行过程。

![image-20210902153448426](https://z3.ax1x.com/2021/09/02/hrNo24.png)

`2` 可以表示  `(a, b, c)` 三个字母，我们先尝试 `2=a` 的时候来到 `3` 节点，对于 `3` 可以表示 `(d, e, f)`，当 `3` 表示 `d` 我们就得到了 `ad`， 然后回到 `3` 节点，它还可以表示 `e` 我们就得到了 `ae`，再回到 `3` 节点还可以表示 `f` 我们就得到了 `af`，此时 `3` 的所以可能已经尝试完了，我们再回到 `2` 节点，`2` 还可以表示 `b`……

通过上面的过程我们得到递归调用一个非常重要的性质——要返回。即递归调用结束之后我们总是要返回到上一层继续调用，每一层的递归调用都是如此，我们要逐步返回，直到在根节点的那次递归调用的所有可能性都尝试完成，我们整个的递归函数才结束。也正是如此我们这种递归尝试寻找答案的规程也被称之为 **回溯**。

也就是说我们沿着一条路径寻找答案，一旦找到答案或者没找到答案就回去继续找，以此类推，这个过程就是回溯。用这个概念看的话我们在上一章学习的跟树相关的算法，本质也是回溯，因为我们使用了递归，递归的话就需要返回。只不过 **回溯法** 这个词通常被用于问题是查找一个解。

上一节算法的时间复杂度大致是 `3^n = O(2^n)`，是一个指数级的算法，所以其效率是非常低的。我们来结合这棵树看，第一层有 3 种情况，第二层有 9 种情况，一直下去，是以指数级上升的。

**回溯法是暴力解法的一个主要实现手段。** 我们遇到是很多问题要枚举其所有可能，如果不能使用简单的循环遍历的话，就需要使用这种回溯法。

大家可以思考下对于这个问题的特点是什么，特点是对于 n 是一个变量。如果它的长度是固定的，比如 8，那我们就可以使用 8 重循环来枚举所有的可能性。但是现在长度是动态的，我们就可以使用这种回溯法来枚举所有的可能性。我们后面会看到动态规划也是在回溯法的基础上构建的。

有些问题我们只能使用回溯法这种暴力解法来解决，但是在回溯的过程中我们可以通过 **剪枝** 不用到达所有的的叶子节点，从而提高算法效率，后面我们将接触到。

## 相关问题

> [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)
>
> 给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 `s` 获得的 **有效 IP 地址** 。你可以按任何顺序返回答案。
>
> **有效 IP 地址** 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。
>
> 例如："0.1.2.201" 和 "192.168.1.1" 是 **有效** IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 **无效** IP 地址。



> [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)
>
> 给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。
>
> **回文串** 是正着读和反着读都一样的字符串。



# 排列问题（全排列）

之前通过一个问题详细介绍了回溯算法，下面几个小节来看看回溯算法的应用，看看它能处理哪些问题。首先回溯算法能处理一类非常重要的问题—— **排列问题**。

## 问题分析

> [46. 全排列](https://leetcode-cn.com/problems/permutations/)
>
> 给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

排列问题的递归回溯结构如下图所示。

![image-20210902165504606](https://z3.ax1x.com/2021/09/02/hr4XjA.png)

用表达式可以表示为：

`Perms( nums[0.n-1] ) = {取出一个数字} + Perms( nums[{0...n-1} - 这个数字] )`

大家要注意这个问题和之前的 [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/) 问题稍有不同，前一个问题每一个数字代表一个字母，数字和数字之间是不冲突的。对本题来说，每次取出一个数字，都影响下一递归调用的要处理的数据范围，为了解决这个问题，我们在编程的时候还需要借助一些辅助的数据结构。

```java
class Solution {
    private List<List<Integer>> res;  // 保存排列结果
    private boolean[] used;           // 记录 nums[i] 是否已经在排列中

    public List<List<Integer>> permute(int[] nums) {
        res = new ArrayList<>();
        used = new boolean[nums.length];
        // 初始调用，目前排列中有 0 个元素
        generatePermutation(nums, 0, new LinkedList<>());
        return res;
    }

    /**
     * list 中保存了一个有 count 个元素的排列，向这个排列的末尾添加第 count + 1 个元素,
     * 获得一个有 count + 1 个元素的排列
     *
     * @param nums  原始数组
     * @param count 已经加入到 list 中排列的元素个数
     * @param list  存放了有 count 个元素的排列
     */
    private void generatePermutation(int[] nums, int count, LinkedList<Integer> list) {
        // 如果排列中保存了全部个数，直接保存结果返回
        if (count == nums.length) {
            res.add((List<Integer>) list.clone());
            return;
        }

        // 遍历所有元素
        for (int i = 0; i < nums.length; i++) {
            // 如果没参与过排列，将其加入到排列中，并记录使用过
            if (!used[i]) {
                list.addLast(nums[i]);
                used[i] = true;
                generatePermutation(nums, count + 1, list);  // 将下一个元素放到排列中
                // 回溯，将元素复位，再进行下一轮循环
                list.removeLast();
                used[i] = false;
            }
        }
    }
}
```

## 相关问题

> [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)
>
>给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

# 组合问题

这一节我们来看回溯算法解决的另一类问题——**组合问题**。

## 问题分析

> [77. 组合](https://leetcode-cn.com/problems/combinations/)
>
> 给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。你可以按 **任何顺序** 返回答案。

组合问题的递归回溯结构如下图所示。

![image-20210902175151911](https://z3.ax1x.com/2021/09/02/hrxdeO.png)

上图即为从 4 个数中取两个数能得到的所有组合，这棵树看起来跟之前的树不一样，之前的树每个节点有集合孩子是固定的，这棵树不固定。但是它依然是这样一个树形的结构，我们依然可以使用递归解决，过程中我们依然能够看到回溯的过程。

上面的递归图跟我们小学做组合题目画的画有相似之处，可以结合起来理解。

![image-20210902180220225](https://z3.ax1x.com/2021/09/02/hsSk2n.png)

我们在每次回溯后再次进行递归操作时，只需要考虑这个元素之后的元素即可，因为前面的元素已经考虑过了。





























组合问题 Combinations
回溯法解决组合问题的优化
二维平面上的回溯法 Word Search
floodfill 算法，一类经典问题 Number of Islands
回溯法是经典人工智能的基础 N Queens