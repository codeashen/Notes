# 二叉树天然的递归结构

## 问题分析

二叉树是天然的递归结构，它的左子树也是二叉树，右子树也是二叉树，并且没有递归终止条件，并且空也是二叉树。

> [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #389e0d;background: #f6ffed;border-color: #b7eb8f;">简单</span>
>
> 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

1. 深度优先遍历（递归）

   ```java
   /**
    * 深度优先遍历（递归）
    * 时间复杂度: O(n)
    * 空间复杂度: O(height)
    */
   class Solution {
       public int maxDepth(TreeNode root) {
           if (root == null) 
               return 0;
           return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
       }
   }
   ```

2. 广度优先遍历（队列）

   ```java
   /**
    * 广度优先遍历（队列）
    * 时间复杂度: O(n)
    * 空间复杂度: 取决于队列中存储的元素，最快 O(n)
    */
   class Solution2 {
       public int maxDepth(TreeNode root) {
           if (root == null) return 0;
           int depth = 0;
           
           Queue<TreeNode> queue = new LinkedList<>();
           queue.offer(root);
           while (!queue.isEmpty()) {
               int size = queue.size();
               for (int i = 0; i < size; i++) {
                   TreeNode node = queue.poll();
                   if (node.left != null) queue.offer(node.left);
                   if (node.right != null) queue.offer(node.right);
               }
               depth++;
           }
           return depth;
       }
   }
   ```

## 相关问题

> [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #389e0d;background: #f6ffed;border-color: #b7eb8f;">简单</span>
>
> 给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

1. 深度优先遍历

   ```java
   /**
    * 深度优先遍历
    * 时间复杂度: O(N)
    * 空间复杂度: O(H)，平均情况下为 O(logN)
    */
   class Solution {
       public int minDepth(TreeNode root) {
           if (root == null) {
               return 0;
           } else if (root.left == null) {
               return minDepth(root.right) + 1;
           } else if (root.right == null) {
               return minDepth(root.left) + 1;
           } else {
               return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
           }
       }
   }
   ```

2. 广度优先遍历

   ```java
   /**
    * 广度优先遍历
    * 时间复杂度: O(N)
    * 空间复杂度: O(N)
    */
   class Solution {
       public int minDepth(TreeNode root) {
           if (root == null) return 0;
           Queue<TreeNode> queue = new LinkedList<>();
           queue.offer(root);
           int minDepth = 1;
   
           while (!queue.isEmpty()) {
               int size = queue.size();
               for (int i = 0; i < size; i++) {
                   TreeNode node = queue.poll();
                   if (node.left == null && node.right == null) {
                       return minDepth;
                   }
                   if (node.left != null) queue.offer(node.left);
                   if (node.right != null) queue.offer(node.right);
               }
               minDepth++;
           }
   
           return 0;
       }
   }
   ```

# 一个简单的二叉树问题引发的血案（翻转二叉树）

## 问题分析

> [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #389e0d;background: #f6ffed;border-color: #b7eb8f;">简单</span>
>
> 翻转一棵二叉树。

```java
/**
 * 递归翻转二叉树
 * 时间复杂度: O(n)
 * 空间复杂度: O(n)
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null)
            return root;

        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        root.left = right;
        root.right = left;
        return root;
    }
}
```

## 相关问题

> [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #389e0d;background: #f6ffed;border-color: #b7eb8f;">简单</span>
>
> 给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。
>
> 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。



> [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #389e0d;background: #f6ffed;border-color: #b7eb8f;">简单</span>
>
> 给定一个二叉树，检查它是否是镜像对称的。



> [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #d46b08;background: #fff7e6;border-color: #ffd591;">中等</span>
>
> 给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。
>
> [完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。
>
> **进阶：**遍历树来统计节点是一种时间复杂度为 `O(n)` 的简单解决方案。你可以设计一个更快的算法吗？



> [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)
>
> 给定一个二叉树，判断它是否是高度平衡的二叉树。
>
> 平衡二叉树：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
>



# 注意递归的终止条件（路径总和）

## 问题分析

对于递归函数很重要的一点就是找到递归终止条件，这里看一个终止条件稍微复杂的题目。

> [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)
>
> 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` ，判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。

1. 深度优先遍历（递归）

   这道题适用递归的思想很简单，递归结构为在根节点 `root` 中查找左右孩子查找是否有 `sum - root.val` 的路径。

   ```java
   /**
    * 递归
    * 时间复杂度: O(n)
    * 空间复杂度: O(h)，最坏链条 O(n)，平均 O(logn)
    */
   class Solution {
       public boolean hasPathSum(TreeNode root, int targetSum) {
           if (root == null)
               return false;
           // 判断是不是叶子节点
           if (root.left == null && root.right == null) {
               return targetSum == root.val;
           } else {
               return hasPathSum(root.left, targetSum - root.val)
                       || hasPathSum(root.right, targetSum - root.val);
           }
       }
   }
   ```

2. 广度优先遍历

   ```java
   // todo
   ```

## 相关题目

> [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)
>
> 计算给定二叉树的所有左叶子之和。



# 定义递归问题（二叉树的所有路径）

前面递归相关题目的逻辑部分都很简单，这一节来看一下逻辑略微复杂一些的题目。在这个问题中大家也可以体会下如何利用递归函数的返回值。

> [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)
>
> 给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。
>
> ![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)
>
> **输入：**root = [1, 2, 3, null, 5]  **输出：**["1->2->5", "1->3"]

这个问题的递归结构也很简单，我们要找从 `root` 出发的所有路径，只需要找到左右子树的所有路径，然后前面加上 `root.val->` ，并合并两组路径即可。这里我们要注意递归终止条件是到达了叶子节点就返回路径，递归的返回值是 **路径数组**。

1. 深度优先遍历（递归）

   这道题适用递归的思想很简单，递归结构为在根节点 `root` 中查找左右孩子查找是否有 `sum - root.val` 的路径。

   ```java
   /**
    * 深优先限遍历（递归）
    * 时间复杂度: O(n), n为树中的节点个数
    * 空间复杂度: O(h), h为树的高度
    */
   class Solution {
       public List<String> binaryTreePaths(TreeNode root) {
           List<String> res = new ArrayList<>();
           if (root == null) 
               return res;
           // 如果是叶子节点，递归结束
           if (root.left == null && root.right == null) {
               res.add(String.valueOf(root.val));
               return res;
           }
           // 不是叶子节点，获取左右子树结果，并处理合并
           List<String> leftRes = binaryTreePaths(root.left);
           List<String> rightRes = binaryTreePaths(root.right);
           for (String item : leftRes)
               res.add(root.val + "->" + item);
           for (String item : rightRes)
               res.add(root.val + "->" + item);
           
           return res;
       }
   }
   ```

2. 广度优先遍历

   ```java
   // todo
   ```

## 相关问题

> [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)
>
> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。
>
> ```
> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 
> 输出：[[5,4,11,2],[5,8,4,5]]
> ```



> [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)
>
> 给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。
>
> 每条从根节点到叶节点的路径都代表一个数字：
>
> - 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。
>
> 计算从根节点到叶节点生成的 **所有数字之和** 。
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)
>
> ```
> 输入：root = [1,2,3]
> 输出：25
> ```

 

# 复杂的递归逻辑（路径总和 III）

> [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)
>
> 给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。
>
> **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
>
> <img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
> 输出：3
> 解释：和等于 8 的路径有 3 条，如图所示。
> ```

之前递归求节点路径的时候，默认当前根节点在路径上，然后在左右孩子中找和为 `targetSum-root.val` 的路径。本题递归有两种情况，一种当前节点在路径上，和上述过程一样；一种当前节点不在路径上，在左右孩子中找和为 `targetSum` 的路径。如下图所示。

![image-20210902091126196](https://z3.ax1x.com/2021/09/02/hD3AJA.png)



```java
/**
 * 双递归
 * 时间复杂度: O(n)
 * 空间复杂度: O(h)
 */
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if (root == null)
            return 0;
        
        // 包含当前节点的结果
        int res = findPath(root, targetSum);
        // 不包含当前节点的结果
        res += pathSum(root.left, targetSum) + pathSum(root.right, targetSum);

        return res;
    }
    
    /**
     * 在 root 为跟的二叉树中，寻找包含 root 的路径，和为 sum
     * @param root      二叉树根节点
     * @param targetSum 路径和
     * @return 返回这样的路径个数
     */
    private int findPath(TreeNode root, int targetSum) {
        if (root == null) 
            return 0;
        
        int res = 0;
        if (targetSum == root.val) 
            res += 1;
        res += findPath(root.left, targetSum - root.val);
        res += findPath(root.right, targetSum - root.val);
        return res;
    }
}
```

由于没有规定路径一定要到叶子节点，并且节点值可能有负数，所以逻辑上比之前的 [112. 路径总和](https://leetcode-cn.com/problems/path-sum/) 和 [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/) 复杂不少，不过思路大致相同。

# 二分搜索树中的问题 Lowest Common Ancestor of a Binary Search Tree

二分搜索树：每个节点的键值大于左孩子;每个节点的键值小于右孩子;以左右孩子为根的子树仍为二分搜索树。

二分搜索树是二叉树的一种，请大家复习二分搜索树的基本操作：

- 插入 insert
- 查找 find
- 删除 delete
- 最大值，最小值 minimum, maximum
- 前驱，后继 successor，predecessor
- 上界，下界 floor，ceil
- 某个元素的排名 rank
- 寻找第 k 大(小)元素 select

由于二分搜索树的结构特点，以上操作的时间复杂度都是 O(logN) 的。

## 问题分析

> [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
>
> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
>
> 最近公共祖先的定义为：对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。

对于根节点 root，我们可以分析输出以下递归结构：

- 如果 p 和 q 都小于 root，则去 root 的左侧找它们的最近公共祖先
- 如果 p 和 q 都大于 root，则去 root 的右侧找它们的最近公共祖先
- 如果 p 和 q 在 root 的两边，则 root 就是它们的最近公共祖先
- 如果 p 和 q 其中之一等于 root，那它就是最近公共祖先

1. 递归

   ```java
   /**
    * 递归
    * 时间复杂度: O(logN)
    * 空间复杂度: O(h)
    */
   class Solution {
       public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
           if (p == null || q == null)
               throw new IllegalStateException("error state");
           if(root == null)
               return null;
           
           if (p.val < root.val && q.val < root.val)
               return lowestCommonAncestor(root.left, p, q);
           if (p.val > root.val && q.val > root.val)
               return lowestCommonAncestor(root.right, p, q);
           return root;
       }
   }
   ```

2. 迭代

   ```java
   /**
    * 迭代
    * 时间复杂度: O(n)
    * 空间复杂度: O(1)
    */
   class Solution {
       public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
           while (true) {
               if (p.val < root.val && q.val < root.val) {
                   root = root.left;
               } else if (p.val > root.val && q.val > root.val) {
                   root = root.right;
               } else {
                   break;
               }
           }
           return root;
       }
   }
   ```

## 相关问题

> [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)
>
> 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
>
> 假设一个二叉搜索树具有如下特征：
>
> - 节点的左子树只包含**小于**当前节点的数。
> - 节点的右子树只包含**大于**当前节点的数。
> - 所有左子树和右子树自身必须也是二叉搜索树。



> [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)
>
> 给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
>
> 一般来说，删除节点可分为两个步骤：
>
> 1. 首先找到需要删除的节点；
> 2. 如果找到了，删除它。
>
> **说明：** 要求算法时间复杂度为 O(h)，h 为树的高度。



> [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)
>
> 给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。
>
> **高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。



> [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)
>
> 给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。



> [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
>
> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
> 最近公共祖先：对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。