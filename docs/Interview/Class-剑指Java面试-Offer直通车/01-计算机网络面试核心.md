# 一、网络基础

## OSI 七层网络模型

国际标准化组织 ISO 制定的 OSI 七层协议模型是业界提出来的概念型框架，是不断迭代出来的，下面看看七层协议是如何进化来的。

![](https://img-blog.csdnimg.cn/2021010409370574.gif)

我们首先要解决两台物理机之间的通信需求，具体就是机器 A 往机器 B 发送比特流，机器 B 能收到这些比特流，这便是物理层要做的事情。物理层主要定义了物理设备的标准，有网线的类型，光纤的接口类型，各种传输介质的传输速率等。它的主要作用，是传输比特流即我们所谓的 0101 二进制数据，让他们转化为电流强弱来进行传输，到达目的地后再转化为的机器码，也就是我们常说的数模转换与模数转换，这层的数据叫做比特。网卡就是工作在这一层里面的。

第二层是数据链路层，在传输比特流的过程中会产生错传、数据传输不完整的可能，因此数据链路层应运而生。数据链路层定义了如何格式化数据进行传输，以及如何控制对物理介质的访问，这一层，通常还提供错误检测和纠正，以确保数据传输的可靠性。本层将比特数据组成了帧，其中，交换机工作在这一层里面，会帧解码，并根据帧中包含的信息把数据发送到正确的接收方。

那随着网络节点的不断增加，点对点通信的时候是需要经过多个节点的，那么如何找到目标节点，如何选择最佳路径便成为了首要需求，此时便有了网络层。这是我们的第三层，将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接受方。综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费，来决定从一个网络中节点 A 到另一个网络中节点B的最佳路径。由于网络层处理并智能指导数据传送，路由器连接网络各段，所以路由器属于网络层，此层的数据我们称之为数据包，本层我们需要关注的协议主要是 TCP/IP 协议里的IP协议。

那么随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输的可能需要很长时间，而网络在通信的过程中会中断好多次，此时为了保证传输大量文件时的准确性，需要对发出去数据进行切分，切割为一个一个的段落即 segment 进行发送，那么其中一个段落丢失了该怎么办？要不要重传？每个段落要按照顺序到达吗？这个便是传输层需要考虑的问题了。传输层解决了主机间的数据传输，数据间的传输可以是不同网络的，并且解决了传输质量的问题，称之为 OSI 模型中最重要的一层。传输协议同时进行流量控制，或是基于接收方可接收数据的快慢程度规定适当的发送速率，除此之外，传输层按照网络能处理的最大尺寸，将较强的数据包进行强制分割，例如以太网无法接收大于 1500 字节的数据包，发送方节点的传输层，将数据呢分割成较小的数据片，同时对每一数据片安排序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组，该过程即称为排序传输。传输层中需要关注的协议有 TCP/IP 协议中的 TCP 协议和 UDP 协议。

现在我们已经保证给正确的计算机发送正确的封装过后的信息了，但是用户级别的体验好不好，难道我每次都要去调用 TCP 去打包，然后就要用 IP 协议去找路由自己去发？当然不行，所以我们要建立一个自动收发包、自动寻址的功能，于是发明了会话层。会话层的作用，就是建立和管理应用程序之间的通信。

现在我能保证应用程序自动收发包和自动寻址了，但我要用 Linux 给 windows 发包，两个系统语法不一致，于是需要表示层帮我们解决不同系统之间的通信语法的问题，在表示层将数据将按照网络能理解的方案进行格式化，这种格式化也因所使用网络的类型不同而不同。

此时，虽然发送方知道自己发送的是什么东西转化成字节数据之后有多长，但接收方肯定不知道，所以应用层的网络协议诞生了，它规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，而且消息投影必须记录消息体的长度等一系列信息，以方便接收方能够正确的解析发送方发送的数据。应用层旨在让你更方便的应用从网络中接收到的数据，至于数据的传递，没有该层你也可以直接在两台电脑间开干，只不过传来传去就是1和0组成的字节数组。该层需要我们重点去关注的是 TCP/IP 协议中的 HTTP 协议。

![](https://z3.ax1x.com/2021/07/09/RjejVx.png)

以上就是关于 OSI 各层次的划分，那从应用层开始都会对要传输的数据头部进行处理，加上本层的一些信息，最终由物理层通过以太网电缆等介质，将数据解析成比特流在网络中传输。数据传递到目标地址，并自底而上的将先前对应层的头部给解析分离出来，这个就是我们的网络数据处理的整个流程。

## TCP/IP 四层网络模型

OSI 是一个定义良好的协议规范级，并有许多可选部分完成类似的任务，它定义了开放系统的层次，结构层次之间的相互关系以及各层所包括的可能的任务，是作为一个框架来协调和组织各层所提供的服务。但是 OSI 参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的制定。 即 OSI 参考模型，并不是一个标准，而是一个在制定标准时所使用的概念性框架。事实的标准是 TCP/IP 四层架构参考模型。

![](https://img-blog.csdn.net/20170822222325781)

TCP/IP 参考模型是计算机网络的祖父ARPANET和其后继的因特网使用的参考模型，市面上绝大多数厂商也以该标准为主，该模型并不完全符合 OSI 的七层参考模型，但我们依然可以理解为它是 OSI 的一种实现。接下来咱们来讲讲这个主流的协议。

从字面上讲，有人可能会认为， TCP/IP 是指TCP和IP这两种协议，实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用IP进行通信时所必须用到的协议群的统称，具体来说IP、icmp、TCP、udp、telnet或者FTP，都属于 TCP/IP 协议。 TCP/IP 与 OSI 在分层模块上稍有区别， TCP/IP 的应用程序可以理解为约等于 TCP/IP 中的应用层、表示层和会话层的组合，同时 OSI 的数据链路层以及物理层在 TCP/IP 中被规定为链路层。 OSI 模型注重通信协议必要的功能是什么，而 TCP/IP 则更强调在计算机上实现协议应该开发哪种程序。

![](https://img-blog.csdn.net/20160802112022872)

从另外一张图里，在数据传输的过程中，我们可以看到和 OSI 一样， TCP/IP 的每个过程中，都会对所发送的数据附加一个头部，在这个头部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常为协议提供的信息为报头的头部，所要发送的内容为数据。从下一层角度上看，数据被传送到接收端之后，再层层解套出来。

## 网络知识参考

- [ OSI 七层模型详解](https://blog.csdn.net/yaopeng_2005/article/details/7064869)
- [ TCP/IP 四层模型](https://blog.csdn.net/csdn_kou/article/details/82910753)
- [ OSI 七层协议模型、 TCP/IP 四层模型和五层协议体系结构之间的关系](https://blog.csdn.net/wxb880114/article/details/82751680)
- [ OSI 七层模型与 TCP/IP 五层模型](https://www.cnblogs.com/qishui/p/5428938.html)

# 二、TCP 三次握手

先来交代一下，IP协议和TCP协议，我们都知道呢，it协议是无连接的通信协议，它不会占用两个正在通信的计算机之间的通信线路，这样IP就降低了对网络效应的需求，每条线可以同时满足许多不同的计算机之间的通信，需要通过IP消息或者其他数据啊会被分割为较小的独立的包，并通过因特网在计算机之间传送IP，负责将每个包路由至它的目的地，当然这些协议呢，没有做任何事情来确认数据包是否按顺序发送，或者包是否被破坏。所以IP数据包呢是不可靠的，需要由他的上层协议来做出控制，前面我们了解到传输控制协议PCP是属于传输层的协议，那法书控制协议啊，可以证明是transmission control protocol缩写，就是我们的tcpr是一种面向连接的可靠的基因字节流的长期层通信协议，数据传输时，应用层向pct发送数据流，然后TCT把数据流分割成适当程度的发文段发文章的长度呢，通常受该计算机连接的网络的数据运用成了最大传输单元及mpe的限制之后呢，TCP把结果包传给IP层，由它来通过网络加包。传送给目标节点的TCP上TCP为了保证物流时报，就给每个包一个序号及sequence number，同时呢序号也保证了传送到目标节点的包的按去除，然后接收到你身体对你成功收到的包呢发回一个相应的确认及ack，确认如果发送端实体在合理的往返10年及rtt内未收到确认，那么对应的数据包就会被假设为已丢失，并且呢将会对其进行重返PCP，用一个基友校验和函数呢来检验数据是否有错误，在发送和接受同时呢都要计算交点和咱们再来学习一下decp帮我们的投入如图所示其中所。 

Port of destination port分别表示原端口和目的端口，他们呢各占两个字节，tsp和后面要学习的udp的数据报呢，都是不包含IP地址信息的，因为那是IP层上的事，但是TCP和udp呢均会有源端口和目的，端口就是说端口这些东西是属于传输层支持范畴的，我们知道两个进程呢在计算机内部进行通信，可以有广告内存，共享信号量消息作业等方法进行通信的，而两个京城如果需要进行通信，最基本的一个前提是能够唯一的标识，一个进程，通过这个唯一标识呢，找到对应的进程，在本地进程通讯中呢，我们可以使用PID及我们的这个。新城教师服务就是我们新城号呢，来唯一标识一个县城，但PID只在本地，唯一如果把两个进程放到了不同的两台计算机，然后他们要进行通信的话呢，PID就不够用了，这样就需要另外一个手段了，解决这个问题的方法就是在传输层中使用协议端口号用的political power number检查关口，我们不知道IP层的IP地址呢，可以唯一标识主机，而TCP协议和端口号呢可以唯一标识主机中的一个进程，像我们可以利用IP地址加协议加端口号，这么一个语音标识呢，去标识网络中的一个进程，在一些场合也把这种唯一标识的模式呢称为套接字及something。也就是说，虽然通信的重点是应用进程，但我们只要把要传送的报文，下达目的主题的某一个合适的端口，剩下的工作就由PCP来完成了，

咱们再来看看比较重要的C和S number就是我们的seq序号，它呢是占了4个字节TCP连接中传送的字节流动的每一个字节呢都按顺序去边好了，例如一段报文的序号字段值就是107儿携带的数据呢，共有100个字段，那么如果有下一个报文段的话呢，情绪好呢，就应该是从107+100=207开始，

接下来也是比较重要的意义，就是我们的这个ack确认号，FM2.0number。同样的是34个字节，是期望收到对方下一个报文的第1个数据字节的序号，B收到了，a发送过来的报文，其序列号字段是301，而数据长度是200字节，这表明了B正确的收到了，a发送的到序号500为止的数据啊，301+200-1就是500规则的数据，因此B希望收到a的下一个数据需要呢是501，于是B在发送给a的确认报文段中会把ack确认号呢置为500名，

接下来就是我们的这个offset结束一片云，由于头部有可选字段长度不固定，因此它指出CCTV报文的。数据距离TCP豹纹的起始处有多远，就是我们的这个offset了，那接下来呢，这个你知道什么呢？是保留率保留今后使用的，但目前呢都可以被标为0。接下来这一个就是我们的PCP flag及控制位需要由8个标志位来组成，每一个标志位表示一个控制功能，咱们需要介绍一下TCP flags中的常见的6个分别是下面这几个，第1个呢是1万镜及紧急指针标示，刚才喂意思呢表示紧急，指针有效为0，则忽略进行自身第2个呢，是ack及确认序号标志为1什么表示确认号有效为0表示。发文中不含确认信息，忽略确认号字段上面的确认号是否有效，就是通过该标识位控制的，第3个呢是psh及push标志，唯一呢表示是带有push标志的数据，只是接收方在接收到该报文段以后呢，应尽快将这个报文段交给应用程序，而不是在缓冲区排队，第4个是ist极为SAT，这是我们的重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接



## 传输控制协议 TCP 简介

- 面向连接的、可靠的、基于字节流的传输层通信协议
- 将应用层的数据流分割成报文段并发送给目标节点的 TCP 层
- 数据包都有序号， 对方收到则发送 ACK 确认， 未收到则重传
- 使用校验和来检验数据在传输过程中是否有误

## TCP 报文头部：

![image-20210819020841734](https://z3.ax1x.com/2021/08/19/f76ASg.png)

- Source Port 、Destination Port：分别表示原端口和目的端口
- Squence Number：序列号
- Acknowledgment Number：确认号
- Offset：数据便宜，由于头部有可选字段，长度不固定，因此它指出 TCP 报文的数据距离 TCP 报文的起始处有多远
- Reserved：保留域
- TCP Flags
  - URG：紧急指针标志
  - ACK：确认序号标志
  - PSH：push 标志
  - RST：重置连接标志
  - SYN：同步序号，用于建立连接过程
  - FIN：finish 标志，用于释放连接
- Window：滑动窗口的大小，用来告知发送端接收端的缓存大小，依次控制发送端发送数据的速率，从而达到流量控制
- Checksum：检验和，有发送端进行存储，并由接收端进行验证
- Urgent Pointer：紧急指针，只有当 TCP Flags 中的 URG 为 1 时才有效，指出本报文段中紧急数据的字节数
- TCP Opions：可选项，其长度可变，定义一些其他的可选参数

## 三次握手过程

![image-20210819024919532](https://z3.ax1x.com/2021/08/19/f7cE4K.png)

在 TCP/IP 协议中, TCP 协议提供可靠的连接服务,采用三次握手建立一个连接。

1. 第一次握手：建立连接时,客户端发送 SYN 包（syn=j）到服务器，并进入 SYN-SEND 状态，等待服务器确认；
2. 第二次握手：服务器收到 SYN 包，必须确认客户的 SYN（ack-j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；
3. 第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK（ack-k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。

## 为什么需要三次握手才能建立起连接

为了初始化 Sequence Number 的初始值

## 首次握手的隐患-SYN 超时

问题起因分析
- Server 收到 Client 的 SYN，回复 SYN-ACK 的时候未收到 ACK 确认
- Server 不断重试直至超时，Linux 默认等待 63 秒才断开连接

针对 SYN Flood 的防护措施

- SYN 队列满后,通过 tcp_ syncookies 参数回发 SYN Cookie
- 若为正常连接则 dien 会回发 SYN Cookie，直接建立连接

## 建立连接后, Client 出现故障怎么办

保活机制

- 向对方发送保活探测报文,如果未收到响应则继续发送
- 尝试次数达到保活探测数仍未收到响应则中断连接

# 三、TCP 四次挥手

## 四次挥手过程

![image-20210819024831703](https://z3.ax1x.com/2021/08/19/f7cAN6.png)

TCP 采用四次挥手来释放连接

1. 第一次挥手：Client 发送一个 FIN，用来关闭 Client 到 Server 的数据传送，Client 进入 FIN_ WAIT_1状态；
2. 第二次挥手：Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为收到序号 +1（与 SYN 相同，一个 FIN  占用一个序号），Server 进入 CLOSE_WAIT 状态；
3. 第三次挥手：Server 发送一个 FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态；
4. 第四次挥手：Client 收到 FIN 后，Client 进入 TIME_WAIT 状态，接着发送一个 ACK 给 Server，确认序号为收到序号 +1，Server 进入 CLOSED 状态，完成四次挥手。

## 为什么会有 TIME WAIT 状态

原因

- 确保有足够的时间让对方收到 ACK 包
- 避免新旧连接混淆

## 为什么需要四次握手才能断开连接

因为全双工，发送方和接收方都需要 FIN 报文和 ACK 报文

## 服务器出现大量 CLOSE_WAIT 状态的原因

对方关闭 socket 连接，我方忙于读或写，没有及时关闭连接

- 检查代码，特别是释放资源的代码
- 检查配置，特别是处理请求的线程配置

# 四、TCP 和 UDP 的区别

## UDP 报文结构

![image-20210819025217451](https://z3.ax1x.com/2021/08/19/f7cQHI.png)

## UDP 的特点

- 面向非连接
- 不维护连接状态，支持同时向多个客户端传输相同的消息
- 数据包报头只有 8 个字节，额外开销较小
- 吞吐量只受限于数据生成速率、传输速率以及机器性能
- 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表
- 面向报文，不对应用程序提交的报文信息进行拆分或者合并

## 结论

从以下几个方面讨论 TCP 和 UDP 的区别

- 面向连接 vs 无连接
- 可靠性
- 有序性
- 速度
- 量级

# 五、TCP 滑动窗口

RTT 和 RTO

- RTT ：一个数据包到收到应的 ACK，所花费的时间
- RTO ：重传时间间隔

TCP 使用滑动窗口做流量控制与乱序重排

- 保证 TCP 的可靠性
- 保证 TCP 的流控特性