# 一、架构

## 如何设计一个关系型数据库？

> 设计一个数据库就跟设计一款软件差不多，也是将其分界成很多模块，面试官问这个也主要是想考查我们的模块划分能力以及对数据库的了解。记忆一个东西的最佳方式便是站在设计者的角度去设计它。

![image-20210817002508406](https://z3.ax1x.com/2021/08/17/fhpWtg.png)

**答：**要设计一个关系型数据库，首相要将其划分成两大部分。一个是存储部分，该部分类似一个文件系统，来将数据持久化到存储设备中。还需要一个程序实例模块，来对存储进行逻辑上的管理。而程序实例模块将包含：

- 将数据的逻辑关系转换成物理储存的存储管理模块
- 优化执行效率的缓存模块
- 将 SQL 语句进行解析的 SQL 解析模块
- 记录操作的日志管理模块
- 进行多用户管理的权限划分模块
- 灾难恢复模块
- 优化数据查询效率的索引模块
- 使数据库支持并发操作的锁模块

# 二、索引

## 为什么要使用索引？

要回答这个问题，咱们先来对数据的查询方式做个调研，先试试最简单的查询方式，即全表扫描。它是将整张表的内容全部或分批次加载到内存中。MySQL 存储的最小单位是块或者页，它们是由多行数据组成的，然后我们将这些块都加载进来，然后逐个块去轮询，找到我们要的目标并返回。这种方式普遍被认为是非常的慢的。

全表扫描在所有的情况下都这么慢吗？存在即合理，它也有很适用的地方，当只有很少量的数据，全部加载到内存里进行全表扫描要比后面说的使用索引的方式要快。当然如果在数据量大的情况下，这种方式显然不适用了。因此这里就引出了我们的答案，很多情况下，我们都需要避免全表扫描的情况发生，索引数据库要引入一种更高效的机制，这便是索引。

索引的灵感来自于字典，依据字母很快就能定位到要查找的内容。而这些定位数据的关键信息便组成了索引，通过索引来大幅提升查询的速度便是问题的答案。但是仅仅这么回答不能让面试官满意，还需要结合后面的内容。

## 什么样的信息能成为索引？

能把数据记录限定在一定查找范围内的字段，主键便是一个很好的切入点，还有唯一键及普通键等。

## 索引的数据结构？

索引数据结构的选择，有以下几种方案

- 生成索引，建立二又查找树进行二分查找
- 生成索引，建立B-Tree结构进行查找
- 生成索引，建立B+-Tree结构进行查找
- 生成索引，建立Hash结构进行查找

接下来我们将各种数据结构用在索引上，一体现其优势和劣势，之后再更为详细地回答问题。

**二叉查找树上阵**

如下图左边所示，模拟使用二叉查找树来生成索引，每个节点存储一个数据和两个指针。二叉查找树使用二分查找查询数据，确实能够提高查询效率，时间复杂度是 O(logN)。但是当数据增加或者删除的时候，例如删除节点 2 和 6 的数据，增加节点 13，二叉树就变成了下图右所示，此时查询的时间复杂度变成了 O(N)，大大降低了查询效率。

![image-20210817013002079](https://z3.ax1x.com/2021/08/17/fhpRAS.png)

有同学可能会说使用树的旋转保证二叉树平衡，就可以维持查询复杂度为 O(logN)。这样确实解决了第一个问题，但是还会有第二个问题。二叉树或者红黑树只能有两个孩子，因此为了组织数据块，索引树的深度就会很深，查询一个数据的查找深度也会很深，影响查询效率。

**B 树**

B 树是一种多路查找树，如果每一个节点最多有 m 个孩子，这样 B 树就是 m 阶 B 树。下图就是一个三阶 B 树。

 ![image-20210817014058573](https://z3.ax1x.com/2021/08/17/fhpg78.png)

对于一个 m 阶 B 树，有以下特征：

- 根节点至少包括两个孩子
- 树中每个节点最多含有 m 个孩子（m>=2）
- 除根节点和叶节点外，其他每个节点至少有 ceil(m/2) 个孩子（ceil 向上取整）
- 所有叶子节点都位于同一层

与其说是特征，不如说是 B 树必须遵守的一个约定，目的就是让每个索引节点存储尽可能多的信息，尽可能减少树的高度，减小查找深度。

最后 B 树还有以下特征：

![image-20210817015343873](https://z3.ax1x.com/2021/08/17/fh9Sj1.png)

以搜索元素 15 为例，讲述 B 树查找元素过程：首先找根节点 `node1(17, 35)`，15 < 17，所以找 17 左边的指针 P1 指向的节点  `node2(8, 12)`，15 > 12，找 12 右边指针 P3 指向的节点 `node3(13, 15)`，至此找到了元素 15。

B 树的查找效率同样是 O(logN)，B 树中增加删除节点时，有其相应的策略，通过合并分裂上一下一节点来维持其特性，让其始终平衡。

**B+ 树**

B+ 树是 B 树的变体，其定义基本与 B 树相同，除了：

- 非叶子节点的子树指针与关键字个数相同
- 非叶子节点的子树指针 `P[i]`，指向关键字值 `[ K[i], K[i+1] )` 的子树
- 非叶子节点仅用来索引，数据都保存在叶子节点中
- 所有叶子节点均有一个链指针指向下一个叶子结点

![image-20210817020915150](https://z3.ax1x.com/2021/08/17/fh91US.png)

> 非叶子节点不存储数据，这样就可以存更多的关键字了，这就使得 B+ 树相对于 B 树来说更矮。B+ 树所有叶子节点链接起来，使得其支持范围查找。

为什么 B+Tree 更适合用来做存储索引：

1. B+ 树的磁盘读写代价更低
2. B+ 树的查询效率更加稳定
3. B+ 树更有利于对数据库的扫描

**Hash 索引也可以考虑以下**

Hash 索引使用 Hash 函数的运算，只需一次就能定位数据所在的头。

![image-20210817022608488](https://z3.ax1x.com/2021/08/17/fh9sC4.png)

缺点：

- 仅仅能满足 “="，“IN"，不能使用范围查询
- 无法被用来避免数据的排序操作
- 不能利用部分索引键查询
- 不能避免表扫描
- 遇到大量 Hash 值相等的情况后性能并不一定就会比 B-Tree 索引高

**BitMap 索引是个神奇**

目前很少有数据库都支持位图索引，比较主流的是 Oracle。

![image-20210817022802418](https://z3.ax1x.com/2021/08/17/fh9629.png)

## 密集索引和稀疏索引的区别？

**密集索引文件中的每个搜索码值都对应一个索引值**

叶子节点保存的不仅仅是键值，还保存了同行记录的其他列信息。密集索引决定了表的配列顺序，一个表只能有一个排列顺序，所以一个表只能创建一个密集索引。

![image-20210817225349374](https://z3.ax1x.com/2021/08/17/fIEg2V.png)

**稀疏索引文件只为索引码的某些值建立索引项**

叶子节点仅保存了键位信息以及该行数据的地址，有的稀疏索引的紧保存了键位信息以及主键。定位到叶子节点后，任然需要通过地址或者主键进一步定位到数据。

![image-20210817225455923](https://z3.ax1x.com/2021/08/17/fIEIa9.png)

以上是一般数据库的情况，下面开始对 MySQL 做具体分析。MyISAN 中的索引均属于稀疏索引，而 InnoDB 必须有且仅有一个密集索引，InnoDB 的密集索引选取规则如下：

- 若一个主键被定义，该主键则作为密集索引
- 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引
- 若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）
- 非主键索引存储相关键位和其对应的主键值，包含两次查找

下图为 InnoDB 和 MyISAM 中通过索引查找数据的过程

![image-20210817231210239](https://z3.ax1x.com/2021/08/17/fImKJA.png)

对于物理文件而言，InnoDB 中索引和数据是存在一起的，而 MyISAM 中索引和数据是分开存储的。如下图所示使用 InnoDB 的 `person_info_large` 表和使用 MyISAM 的 `shop_info_small` 表，其中 `frm` 文件存储表结构。

![image-20210817231851675](https://z3.ax1x.com/2021/08/17/fInZ60.png)

## 如何定位并优化慢查询

步骤：

1. 根据慢日志定位慢查询 sql
2. 使用 explain 等工具分析 sql
3. 修改 sql 或者尽量让 sql 走索引

下图是慢查询日志的内容

![image-20210817234553183](https://z3.ax1x.com/2021/08/17/fIMLHf.png)

## 联合索引的最左匹配原则的成因

什么是联合索引的最左匹配原则：

- **最左前缀匹配原则**，mysql 会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配，比如 `a=3 and b=4 and c>5 and d=6` 如果建立 `(a,b,c,d)` 顺序的索引，d 是用不到索引的，如果建立 `(a,b,d,c)` 的索引则都可以用到，a、b、d 的顺序可以任意调整。
- `=` 和 `in` 可以乱序，比如 `a=1 and b=2 and c=3` 建立 `(a,b,c)` 索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。

联合索引的最左匹配原则的成因：

MySQL 在创建联合索引的规则，是首先对联合索引的第一个字段进行排序，在第一个字段排序的基础上在对第二个字段进行排序，依次类推。多以联合索引的第一个字段是绝对有序的，之后的字段都是在前一个字段的基础上小范围再排序，所以跳过之前的字段是无法使用到后面字段的索引的。

## 索引是建立得越多越好吗

- 数据量小的表不需要建立索引，建立会增加额外的索引开销
- 数据变更需要维护索引，因此更多的索引意味着更多的维护成本
- 更多的索引意味着也需要更多的空间

# 三、锁

## MyISAM 与 InnoDB 关于锁方面的区别是什么

先给出答案：

- MyISAM 默认用的是表级锁，不支持行级锁
- InnoDB 默认用的是行级锁，也支持表级锁

!> InnoDB 在 sql 用到索引的时候加的是行级锁和间隙锁，sql 没有用到索引的时候用的加的是表级锁

是不是行级锁一定比表级锁好呢？那倒未必，锁的粒度越细，代价越高。相比表级锁直接在表的头部加锁来讲，行级锁还需要扫描到某行的时候对其上锁，这样代价是比较大的。InnoDB 支持事务的同时，也相比 MyISAM 引擎带来了更大的开销。

## MyISAM 和 InnoDB 的适用场景

MyISAM 适合场景：

- 频繁执行全表 count 语句

  InnoDB 是不保存表的行数的，执行全表 count 时需要重新扫描统计；而 MyISAM 用一个变量保存了整个表的行数，执行 count 查询时只需要读出该变量，速度很快。

- 对数据进行增删改的频率不高，查询非常频繁

- 没有事务

InnoDB 适合场景：

- 数据增删改查都相当频繁
- 可靠性要求比较高，要求支持事务

## MySQL 锁的分类

- 按锁的粒度划分，可分为表级锁、行级锁、页级锁
- 按锁级别划分，可分为共享锁、排它锁
- 按加锁方式划分，可分为自动锁、显式锁
- 按操作划分，可分为DML锁、DDL锁
- 按使用方式划分，可分为乐观锁、悲观锁

InnoDB 默认支持行级锁，同时支持表级锁，InnoDB 对行级上锁时，会先上一种表级别的意向锁。MyISAM 仅支持表级锁，不常用的 BDB 引擎支持页级锁。

MySQL 执行语句自动加的锁是自动锁，而 `select ... for update` 和 `lock in share mode` 属于显示锁。

悲观锁：对数据被外界的修改持保守态度，因此在整个数据梳理过程中，将数据处于锁定状态。悲观锁的实现往往依靠数据库的锁机制。全程用排他锁锁定正是一种悲观锁的实现，悲观并发控制实际上是先取锁，再访问的保守策略，对数据处理的安全提供了保证。但是从效率而言，处理加锁的机制会让数据库产生二外的开销，增加产生死锁的机会。

乐观锁：乐观锁认为数据一般情况下不会产生冲突，所以在数据进行提交更新的时候才会正式对数据的冲突与否进行检测，如果发生冲突则返回错误信息给用户，让用户决定如果处理。乐观锁并不会使用数据库的锁机制，一般的乐观锁实现就是记录数据版本，即使用版本号或时间戳。

## 数据库事务的四大特性

- **原子性（Atomic）**：事务包含的操作要么全部MS执行，要么全部失败回滚。
- **一致性（Consistency）**：事务应确保数据库的状态从一个一致状态转变为另一个一致状态，一致性状态是指数据库中的数据应满足完整性约束。
- **隔离性（Isolation）**：多个事务并发执行时，一个事务的执行，不应该其他事务的执行。
- **持久性（Durability）**：一个事务一旦提交，它对数据库的修改应该永久保存在数据库中。持久性意味着当系统或者介质发生故障时，确保已提交事务的更新不能丢失，即对已提交事务的能恢复。一旦一个事务被提交，BDMS 必须保证提供适当的冗余，使其耐得住系统的故障，所以持久性主要在于 BDMS 的恢复性能。那 InnoDB 来讲，会将所有对数据的修改写入 redo_log，并在数据库启动时从此文件进行恢复操作，redo_log 保证了数据库的持久性。

## 事务隔离级别以及各级别下的并发访问问题

事务并发访问引起的问题以及如何避免

- 更新丢失 —— mysql 所有事务隔离级别在数据库层面上均可避免
- 脏读 —— READ-COMMITTED 事务隔离级别以上可避免
- 不可重复读 —— REPEATABLE-READ 事务隔离级别以上可避免
- 幻读 —— SERIALIZABLE 事务隔离级别可避免

![image-20210818012203586](https://z3.ax1x.com/2021/08/18/fIGRHI.png)

## InnoDB 可重复读隔离级别下如何避免幻读

这里分为表象和内在，表象是我们能看到的现象，并不是真正的原因，原因体现在内在。

- 表象：快照读（非阻塞读）—— 伪 MVCC
- 内在：next-key 锁（行锁 + Gap 锁）

表象是在 RR 级别下，基于伪 MVCC 机制实现的快照读，来避免读到幻行。先来介绍下 **快照读** 和当 **前读取**。

- 当前读：select...lock in share mode，select...for update 
- 当前读：update，delete，insert
- 快照读：不加锁的非阻塞读，select

其实当前读就是加了锁的增删改查语句，为什么叫当前读呢，因为它都的是记录的最新版本，读取之后还需要保证其他并发事务不能修改当前记录，对读取的记录加锁。上述操作中，除了 `select...lock in share mode` 是加共享锁，其他的都是加的排他锁。为什么 update，delete，insert 也是当前读呢？

**（1）当前读介绍**

咱们了解到 RDBMS 组要由两大部分组成，程序实例和存储，下图中程序实例即 MySQL Server 的实例，存储是 InnoDB。我们拿图中 update 语句为例，分析流程：

![image-20210818013751556](https://z3.ax1x.com/2021/08/18/fIJGIP.png)

1. 当 sql 发给 MySQL 之后，MySQL Server 会根据 where 条件读取第一条满足条件的记录 （select row 1）
2. InnoDB 会将第一条记录返回并加锁（return & lock）
3. MySQL Server 接收到这条加锁的记录后，会发起一个 update 操作去更新这条记录（update row）
4. 一条记录更新完成后，再读取下一条记录，直至没有满足条件的记录为止（finished）

上图中，update 操作内部就包含了一个当前读（current read）来获取数据的最新版本。在 RC 隔离级别下，update 语句全表的时候，就能读到此事务过程中别的事务 insert 的记录，即读取到了数据的最新版本，同理 delete 操作也一样。而 insert 操作略由不同，简单来说就是 insert 操作可能会触发唯一键的冲突检查，所以也会进行一个当前读取。

**（2）快照读介绍**

快照读和当前读不同，它就是简单的 select 操作，不加锁。注意这是在事务隔离级别不为 SERIALIZABLE 的前提下，SERIALIZABLE 下由于是串行读，所以此时的快照读也退化成当前读，即 `select...lock in share mode` 模式。

之所以出现快照读，是基于提升并发性能的考虑，快照读是基于多版本并发控制，即 MVCC。可以认为 MVCC 是行级锁的一个变种，它在很多情况下避免了加锁操作，因此开销更低。既然是基于多版本，也就意味着快照读有可能读到的并不是数据的最新版本，可能是之前的历史版本。之所以说是可能，是因为 RR 隔离级别下，事务首次调用快照读的地方很关键，也就是创建快照的时机，决定了读取数据的版本。

## RC、RR 级别下的 InnoDB 的非阻塞读如何实现

InnoDB 在 RC、RR 级别下实现快照读离不开下面三个因子：

1. 数据行里的 DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID 字段
2. undo 日志
3. read view

下面一一介绍上述三个因子

**（1）DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID 字段**

- `DB_TRX_ID`：最后一次更新本行数据的事务 id
- `DB_ROLL_PTR`：回滚指针（db roll pointer），指向对应的 undo log
- `DB_ROW_ID`：行号，单调递增的行 id，当由 InnoDB 自动产生聚集索引时，聚集索引会包括这个行 id 的值，否则这个行 id 不会出现在任何索引中

**（2）undo 日志**

当我们对记录做了变更操作时便会产生 undo 记录，记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读到老版本数据，需要顺着 undo 链找到满足其可见性的记录。

undo log 主要分为两种：insert undo log 和 update undo log。其中 insert undo log 事务对 insert 操作产生的 undo log，只在事务回滚时需要，并且在事务提交后就可以立即丢弃。update undo log 不仅在事务回滚时需要，快照读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的 undo log 才会被 purge 线程删除。

日志的工作方式：

假设需要对 DB_ROW_ID 为 1 的数据做更新操作，这一行被事务 A 修改，讲 Field2 的值从 12 改为了 32。修改的流程是这样的，首先用排他锁锁定该行，随后把该行修改前的值拷贝一份到 undo log 里，最后修改当前行的值，填写事务id（DB_TRX_ID），适用回滚指针（DB_ROLL_PTR）指向 undo log 中修改前的行。

![image-20210818021950767](https://z3.ax1x.com/2021/08/18/fIYD6e.png)

在这之后，假设数据库还有别的事务在用快照读读取该日志记录，对应的 undo log 还没有被清除，此时某一个事务又对同一行数据做了修改，将 Field3 从 13 改为 45，效果和上一张图一样，又多了一条 undo log 记录。数据的多个版本就是这样实现的，undo log 通过 DB_ROLL_PTR 连接起来形成了 undo log 链。

![image-20210818022025426](https://z3.ax1x.com/2021/08/18/fIYBlD.png)

**（3）read view**

read view 主要用来做可见性判断，即当我们执行快照读会针对我们查询的数据创建出一个 read view，来决定当前事务能看到哪个版本的数据。有可能是当前最新版本的数据，也有可能是 undo log 中某个版本的数据。

read view 遵循一个可见性算法，主要是讲要修改的数据的 DB_TRX_ID 取出来，与系统其他活跃事务 id 做对比，如果大于等于这些活跃事务 id，就通过 DB_ROLL_PTR 指针去取出 undo log 上一层的 DB_TRX_ID，直到小于这些活跃事务 id 为止，这样就保证了我们的数据版本是当前可见的最稳定的版本。

真是因为生成时机的不同，造成了 RC、RR 级别下的不同可见性。在 RR 级别下，`start transaction` 后的第一条快照读会创建一个快照，即 read view，将当前系统中活跃的其他事务记录起来，此后再调用快照读的时候还是用的同一个 read view；而在 RC 级别下，事务中每次调用快照读的时候都会创建一个新的快照。这就是之前为什么 RC 级别下能用快照读看到别的事务对已提交的增删改数据；而在 RR 级别下如果首次适用快照读是在别的事务执行增删改操作并提交之前的，此后即便别的事物提交了增删改，本事务中还是读不到数据变更的原因。对于 RR 来讲，首次事务 select 的时机是非常关键的。

正因为以上的三个因子，才使得 InnoDB 在 RR、RC 级别支持非阻塞读，而读取数据时的非阻塞就是所谓的 MVCC，而 InnoDB 的非阻塞读实现了仿照版的 MVCC。MVCC 指的 Multi-Version Concurrency Control，即多版本并发控制，读不加锁，读写无冲突，在读多写少的场景下读写不冲突是非常重要的，极大的增加了系统的并发性能。那为什么说 InnoDB 仅实现了伪 MVCC 机制呢？因为本没有实现核心的多版本共存，undo log 中的内容只是串行化的结果，记录了多个事务的过程，部署于多版本共存。

## RR 级别下 InnoDB 如何避免幻读

在前面我们了解到，InnoDB 在 RR 级别下具备让我们看不到幻行的能力，但这并不意味着快照读是避免幻读现象发生的根本，只是当前事务打开 read view 时，无论别的事务是否提交，当前事务下再次调用快照读到的读到的任是可见性版本内的数据，有种掩耳盗铃的意味在里面。

**其实在 RR、serializable 级别下真正防止幻读发生的是因为事务对数据加了 next-key 锁。**next-key 锁由两部分组成，**行锁** 和 **Gap 锁**。行锁是对数据行上的锁，这里的关键是 Gap 锁。

- 定义：Gap 就是索引树中插入新纪录的空隙，而 Gap lock 间隙锁，即锁定一个范围，但不包括记录本身。
- 目的：Gap 锁的目的是防止同一事务的两次当前读出现幻读的情况。
- 支持的隔离级别：Gap 锁在 RC 及以低隔离级别下是没有的，所以这就是 RC、READ-UNCOMMIT 级别下无法避免幻读的原因；而 RR、SERIALIZABLE 默认都支持 Gap 锁。

下面主要讨论 RR级别下 Gap 锁出现的场景，在 RR 下，无论删改查，当前读若用到主键或唯一索引会用到 Gap 锁吗？视情况而定

- **如果 where 条件全部命中，则不会用 Gap 锁，只会加记录锁**
- **如果 where 条件部分命中或者全不命中，则会加 Gap 锁**

什么叫全部命中，可以理解为精确查询的时候，所有记录都有。比如 `where id in (1,3,5)` ，此时 id 为 1、3、5 的数据均在表中存在并且出现，就是全部命中。由此，部分命中即为范围查询或者精确查询非全部命中的情况。

需要注意的是，加锁的时候如果走的是主键之外的索引，那么 MySQL 会对当前索引以及该记录主键上的索引都上锁。下面补充加锁流程，如下图所示，name 为主键，id 为唯一键，执行 `delete from tb where id = 9`，该如何进行加锁呢？此时由于 id 是唯一索引，MySQL 会选择走 id 上的唯一索引进行过滤，在找到 id 为 9 的索引后，该索引记录加行排他锁锁，同时根据读到的 name 为 d 的主键回到主键密集索引，然后将密集索引上 name 为 d 的主键索引项也加上排他锁。

![image-20210819003156634](https://z3.ax1x.com/2021/08/19/f700fJ.png)

为什么这么做呢，因为如果通过非主键索引 delete 的同时，别的事务通过主键索引更新相同的数据，两个事务操作使用不同的索引操作同一数据，如果 delete 语句没有将主键索引上锁，另一个并发的更新事务就感知不到 delete 的存在，这样就违背的同意记录上的更新或者删除需要串行执行的约束。

现在已经对 Gap 锁有了初步印象，接下来仔细研究 Gap 锁。

**Gap 锁会用在非唯一索引或者不走索引的当前读中**

先来看走非唯一所以的情况，下图表中 name 为主键，id 为非唯一索引键。如事务 A 在当前读中读取 id=9 的记录读到了 2 条，此时事务 B 在插入 1 条 id 为 9 的记录并提交，回到事务 A 中再次使用当前读就会读到 3 条 id=9 的记录，这样就发生了幻读。因此我们需要引入 Gap 锁。

Gap 锁具体怎么在什么地方添加呢？我们先来看看那些地方算作是 Gap，从图中可以看到 Gap 的地方跟我们走的非唯一索引的值分布由很大关系，都是一个左开右闭的区间，一旦着这些区间上加了 Gap 锁，在区间内就无法插入数据了，因此 Gap 锁是用来防止插入的。对于普通的非唯一索引来讲，并不是所有的 Gap 都会上锁，只会对要修改地方的周边上 Gap 锁。例如下图中会对 (6,9] 和 (9,11] 两个 Gap 上锁，此时别的事物向插入 id 为这两个区间内的数据是会被阻塞住的。

![image-20210819010500618](https://z3.ax1x.com/2021/08/19/f7DhQA.png)

> 附：具体可参考官方文档  [Next-Key Locks](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-next-key-locks)

接下来再看不走索引的情况，当当前读不走索引的情况，会对所有的 Gap 都上锁，这也就类似缩表了，这样也同样能达到防止幻读的效果。如下图所示，删除没有任何索引的 id=9 的数据，所有的 Gap 都会被锁住。 不过相比表锁，这样上锁的代价更大，通常是需要避免的，因为会减低数据库的效率。

![image-20210819012047166](https://z3.ax1x.com/2021/08/19/f7rG6A.png)

!> **总结：**InnoDB RR 级别下主要通过引入 next-key 锁来避免幻读问题，而 next-key 由行锁和 Gap 锁组成，Gap 锁会用在非唯一索引或者不走索引的当前读中，以及仅命中检索条件部分结果集并且用到主键索引和唯一索引的当前读中。

# 四、语法

## 关键语法

- GROUP BY
- HAVING
- 统计相关: COUNT , SUM , MAX , MIN , AVG

## GROUP BY

- 满足 "SELECT 子句中的列名必须为分组列或列函数"
- 列函数对于 group by 子句定义的每个组各返回一个结果

## HAVING

- 通常与 GROUP BY 子句一起使用
- WHERE 过滤行, HAVING 过滤组
- 出现在同一 sql 的顺序: WHERE > GROUP BY > HAVING

