## 缓存中间件一 Memcache 和 Redis 的区别

Memcache：代码层次类似 Hash

- 支持简单数据类型
- 不支持数据持久化存储
- 不支持主从
- 不支持分片

Redis

- 数据类型丰富
- 支持数据磁盘持久化存储
- 支持主从
- 支持分片

## 为什么 Redis 能这么快

- 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高
- 数据结构简单，对数据操作也简单
- 采用单线程，单线程也能处理高并发请求，想多核也可启动多实例
- 使用多路 IO 复用模型，非阻塞 IO

## IO 多路复用

FD：File Descriptor，文件描述符

一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射

传统的阻塞 I/O 型

![image-20210824074636997](https://z3.ax1x.com/2021/08/24/hiykmd.png)

当使用 read 或者 write 对某个文件描述符 FD 进行读写时，如果当前 FD 不可读或者不可写，整个程序就不会对其他操作做出响应，导致整个服务不可用，这就是传统的阻塞模型。

Select系统调用

![image-20210824075008516](https://z3.ax1x.com/2021/08/24/hiyZkt.png)

## Redis 采用的 I/O 多路复用函数: epoll/kqueue/evport/select?

- 因地制宜
- 优先选择时间复杂度为 O(1) 的 I/O 多路复用函数作为底层实现
- 以时间复杂度为 O(n) 的 select 作为保底
- 基于 react 设计模式监听 I/O 事件

## Redis 数据类型

- String : 最基本的数据类型，二进制安全
- Hash : String 元素组成的字典，适合用于存储对象
- List : 列表，按照 String 元素插入顺序排序
- Set : String 元素组成的无序集合，通过哈希表实现，不允许重复
- Sorted Set : 通过分数来为集合中的成员进行从小到大的排序
- 用于计数的 HyperLogLog，用于支持存储地理位置信息的 Geo

## 从海量数据中获取某一固定前缀的key

避免使用 `keys` 指令，因该使用 `SCAN`

`SCAN cursor [MATCH pattern] [COUNT count]`

- 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程
- 以 0 作为游标开始一次新的迭代，直到命令返回游标 0 完成一次遍历
- 不保证每次执行都返回某个给定数量的元素，支持模糊查询
- 一次返回的数量不可控，只能是大概率符合 count 参数

> 例：`scan 0 match spring* 10`

## 如何通过 Redis实现分布式锁

分布式锁需要解决的问题：

- 互斥性：同一时刻只能有一个客户端持有锁
- 安全性：锁只有有持有锁的客户端删除，不能被其他客户端删除
- 死锁：避免持有锁的客户端宕机没有释放锁，从而其他客户端再也无法获取到锁
- 容错：部分 redis 节点宕机，客户端任然能正常获取释放锁

借助 setnx 指令并设置过期实际按实现分布式锁，如果 key 不存在，创建并赋值，即 set not exist。成功返回 1，失败返回 0，指令操作是原子的。

- `SETNX key value`
- ``EXPIRE key seconds`

但是上述指令不是原子的，可以使用以下原子指令同时设置键值和过期时间：

`Set key value [EX seconds] [PX milliseconds] [NX|XX]`

- EX second：设置键的过期时间为 second 秒
- PX millisecond：设置键的过期时间为 millisecond 毫秒
- NX：只在键不存在时，才对键进行设置操作
- XX：只在键已经存在时，才对键进行设置操作
- SET 操作成功完成时，返回 OK，否则返回 nil

## 如何使用 Redis 做异步队列

使用 Redis 作异步队列有三种方案：

1. 使用List作为队列，RPUSH生产消息，LPOP消费消息
   - 缺点：不会等待队列里有值再去消费，如果队列没有数据就直接返回了
   - 弥补：可以通过在应用层引入 sleep 机制去调用 LPOP 重试
2. BLPOP key [key...] timeout`，阻塞直到队列有消息或者超时
   - 缺点:只能供一个消费者消费
3. pub/sub：主题订阅者模式
   - 发送者(pub)发送消息，订阅者(sub)接收消息
   - 订阅者可以订阅任意数量的频道
   - 缺点：消息的发布是无状态的，订阅者无法收到订阅操作前的消息

## Redis 如何做持久化

### RDB

RDB(快照)持久化：保存某个时间点的全量数据快照

手动触发 RDB 持久化的方式：

- SAVE：阻塞 Redis 的服务器进程，直到 RDB 文件被创建完毕
- BGSAVE：Fork 出一个子进程来创建 RDB 文件，不阻塞服务器进程

自动化触发 RDB 持久化的方式

- 根据 redis.conf 配置里的 `SAVE mn` 定时触发（用的是 BGSAVE）
- 主从复制时，主节点自动触发
- 执行 Debug Reload
- 执行 Shutdown 且没有开启 AOF 持久化

**BGSAVE 原理**

![image-20210824085412398](https://z3.ax1x.com/2021/08/24/hiRNy8.png)

在执行 bgsave 指令后，redis 首先会检查是否有正在执行的 AOF 或 RDB 子进程，有则返回错误，这样做是为了防止子进程之间的竞争，也就意味着在执行 bgsave 期间客户端发送的 save/bgsave 指令会被拒绝执行。如果此时没有发现相关子进程，就会触发持久化，就会调用 redis 源码里的 rdbSaveBackground 方法，执行 fork 系统调用。

系统调用 fork()：创建进程，实现了 Copy-on-Write，写时复制。传统方式下 fork 函数在创建子进程时直接把所有资源赋值给子进程，这种实现方式简单，但是效率低下，而且复制的资源可能对子进程毫无用处。linux 为了降低创建子进程的成本改进 fork 实现方式，当父进程创建子进程时，内核只为子进程创建虚拟空间，父子两个进程使用的是相同的物理空间，只有父子进程发生更改时，才会为子进程分配独立的空间。此种改进的方式称之为 Copy-on-Write，其核心思想是，如果有多个调用者同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。

当 Redis 需要作持久化时间，会 fork 出子进程，子进程将数据写到磁盘上的一个临时 rdb 文件中，当子进程完成写入后，替换原来的 rdb 文件，此期间父进程可以继续处理客户端请求。由于 OS 的 Copy-on-Write 机制，父子进程会共享相同的物理页面，当父进程处理写请求时，OS 会为父进程要修改的页面创建副本，而不是写共享的副本，所以子进程地址空间内的数据的 fork 时刻整个数据库的快照，子进程完成写入后用临时文件替换原 rdb 文件。rdb 文件的载入是自动的，redis server 再次启动时，如果检测到 rdb 文件的存在，redis 会自动载入这个文件。

RDB 的缺点：

- 内存数据的全量同步，数据量大会由于 I/O 而严重影响性能
- 可能会因为 Redis 挂掉而丢失从当前至最近一次快照期间的增量数据

### AOF

与 RDB 持久化不同，AOF 是保存数据库的写状态。具体来说，rdb 相当于备份数据库状态，而 aof 相当于备份数据库接收到的指令。

- 记录下除了查询以外的所有变更数据库状态的指令
- 以 append 的形式追加保存到 AOF 文件中（增量）

日志重写解决AF文件大小不断增大的问题，原理如下:

- 调用 fork()，创建一个子进程
- 子进程把新的 AOF 写到一个临时文件里，不依赖原来的 AOF 文件
- 主进程持续将新的变动同时写到内存和原来的 AOF 里
- 主进程获取子进程重写 AOF 的完成信号，往新 AOF 同步增量变动
- 使用新的 AOF 文件替换掉旧的 AOF 文件

**RDB 和 AOF 文件共存情况下的数据恢复流程**

![image-20210824102811796](https://z3.ax1x.com/2021/08/24/hivJsg.png)

redis server 重启后，会先检查是否有 AOF 文件，如果有就直接加载 AOF 文件，否则加载 RDB 文件，都不存在就都不加载。

### RDB 和 AOF 的优缺点

RDB：

- 优点：全量数据快照，文件小，恢复快
- 缺点：无法保存最近一次快照之后的增量数据

AOF：

- 优点：可读性高，适合保存增量数据，数据不易丢失
- 缺点：文件体积大，恢复时间长

### RDB 和 AOF 混合持久化

Redis 4.0 之后推出了结合 RDB 和 AOF 的混合持久化模式，在这种方式下，子进程在做 AOF 重写时，会通过管道从父进程读取增量数据并缓存下来，再以 RDB 格式保存全量数据时，也会从管道读取数据，同时不会造成管道的阻塞，也就是说 AOF 文件的前半段是 RDB 格式的全量数据，而后半段是 redis 命令格式的增量数据。

![image-20210824103434637](https://z3.ax1x.com/2021/08/24/hixFTs.png)

总结来说，RDB 和 AOF 的混合持久化方式是目前较为推荐的 redis 持久化方式，此种方式是用 BGSAVE 作镜像全量持久化，AOF 作增量持久化。因为 BGSAVE 会耗费较长时间，不够实时，在停机时会导致大量丢失数据的问题，所以需要 AOF 来配合使用。在 redis 重启时，会使用 BGSAVE 持久化的文件重新构建内容，在使用 AOF 重放近期的操作指令，来实现完整恢复重启前的状态。

## 为什么要使用 Pipeline

- Pipeline 和 Linux 的管道类似
- Redis 基于请求/响应模型，单个请求处理需要——应答
- Pipeline 批量执行指令，节省多次 10 往返的时间
- 有顺序依赖的指令建议分批发送

## Redis 同步机制























