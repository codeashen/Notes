# 在节点间穿针引线（反转链表）

## 题目分析

> [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
>
> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

通常情况下链表问题我们是不能操作节点中值的，应该操作节点的指向，即实现如下图操作。

![image-20210830223959459](https://z3.ax1x.com/2021/08/30/hND6s0.png)

在遍历链表时，将当前节点的 `next` 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。整体过程如下图。

![image-20210830224917942](https://z3.ax1x.com/2021/08/30/hNsM3d.png)

## 代码实现

1. 迭代法

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode() {}
    *     ListNode(int val) { this.val = val; }
    *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    * }
    * 迭代法
    * 时间复杂度: O(n)
    * 空间复杂度: O(1)
    */
   class Solution {
       public ListNode reverseList(ListNode head) {
           ListNode cur = head;   // 保存当前遍历的节点
           ListNode pre = null;   // 保存前一个节点
           while (cur != null) {
               ListNode next = cur.next;  // 暂存下一个节点
               cur.next = pre;  // 指针反转
               // 操作完成，pre 和 cur 后移动一位，继续
               pre = cur;
               cur = next;
           }
   
           return pre;
       }
   }
   ```

2. 递归法。递归法比较难懂，借助 LeetCode 解题理解。

   ```java
   /**
    * 递归
    * 时间复杂度: O(n)
    * 空间复杂度: O(n)
    */
   class Solution {
       public ListNode reverseList(ListNode head) {
           if (head == null || head.next == null) {
               return head;
           }
           ListNode newHead = reverseList(head.next);  // newHead 始终是原链表的尾节点
           head.next.next = head;  // 将下一节点的 next 指向自己，形成环
           head.next = null;       // 保留反转后的指向，取消原指向，解开环
           return newHead;         // 返回原链表的尾节点
       }
   }
   ```

## 相关问题

> [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
>
> 给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 right 的链表节点，返回 **反转后的链表** 。

1. 截取拼接子链表，两次遍历。

   ```java
   /**
    * 两次遍历迭代法，截取拼接
    * 时间复杂度: O(N)
    * 空间复杂度: O(1)
    */
   class Solution {
       public ListNode reverseBetween(ListNode head, int left, int right) {
           // 因为头节点可能参与反转，设置虚拟头节点可以避免复杂的分类讨论
           ListNode dummyHead = new ListNode(-1);
           dummyHead.next = head;
   
           // 从虚拟头节点走 left - 1 步，定位到子链表前驱节点
           ListNode pre = dummyHead;
           for (int i = 0; i < left - 1; i++) {
               pre = pre.next;
           }
   
           // 从 pre 再走 right - left + 1 步，定位到子链表 right 节点
           ListNode rightNode = pre;
           for (int i = 0; i < right - left + 1; i++) {
               rightNode = rightNode.next;
           }
   
           // 定位子链表 left 节点和后继节点 succ
           ListNode leftNode = pre.next;
           ListNode succ = rightNode.next;
   
           // 截断子链表
           pre.next = null;
           rightNode.next = null;
   
           // 反转子链表
           reverseList(leftNode);
   
           // 将子链表拼接回去
           pre.next = rightNode;
           leftNode.next = succ;
   
           return dummyHead.next;
       }
   
       // 完整反转链表方法，也可以使用递归
       private void reverseList(ListNode head) {
           ListNode cur = head;
           ListNode pre = null;
           while (cur != null) {
               ListNode nextNode = cur.next;
               cur.next = pre;
               pre = cur;
               cur = nextNode;
           }
       }
   }
   ```

2. 头插法。一次遍历，且步骤简洁。思路参考：[Java-双指针-头插法](https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/java-shuang-zhi-zhen-tou-cha-fa-by-mu-yi-cheng-zho/)

   ```java
   /**
    * 头插法
    * 时间复杂度: O(N)
    * 空间复杂度: O(1)
    */
   class Solution {
       public ListNode reverseBetween(ListNode head, int left, int right) {
           // 因为头节点可能参与反转，设置虚拟头节点可以避免复杂的分类讨论
           ListNode dummyHead = new ListNode(-1);
           dummyHead.next = head;
   
           // 定位子区间的前驱节点 pre 和区间起点 leftNode
           ListNode pre = dummyHead;
           for (int i = 0; i < left - 1; i++) {
               pre = pre.next;
           }
           ListNode leftNode = pre.next;
           
           // 循环将 leftNode 右边的头插到 pre 后面，结束后 leftNode 来到子区间右边
           for (int i = 0; i < right - left; i++) {
               // 移除后面一个节点，摘出来
               ListNode removeNode = leftNode.next;
               leftNode.next = leftNode.next.next;
               // 将摘出来的节点拼到 pre 后面
               removeNode.next = pre.next;
               pre.next = removeNode;
           }
   
           return dummyHead.next;
       }
   }
   ```

> [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)
>
> 存在一个按升序排列的链表，给你这个链表的头节点 `head` ，请你删除所有重复的元素，使每个元素 **只出现一次** 。返回同样按升序排列的结果链表。

```java
/**
 * 一次遍历
 * 时间复杂度: O(N)
 * 空间复杂度: O(1)
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null)
            return head;
        
        ListNode cur = head;
        while (cur.next != null) {
            if (cur.next.val == cur.val)
                cur.next = cur.next.next;
            else
                cur = cur.next;
        }
        return head;
    }
}
```

> [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)
>
> 给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。你应当 **保留** 两个分区中每个节点的初始相对位置。

1. 分成两个链表，再拼接。

   ```java
   /**
    * 分组拼接
    * 时间复杂度: O(N)
    * 空间复杂度: O(1)
    */
   class Solution {
       public ListNode partition(ListNode head, int x) {
           // 分成大链表和小链表
           ListNode smallHead = new ListNode(0);   // 小链表头（虚拟）
           ListNode smallTail = smallHead;         // 小链表尾
           ListNode largeHead = new ListNode(0);   // 大链表头（虚拟）
           ListNode largeTail = largeHead;         // 大链表尾
           
           // 遍历节点，将元素划分到两个链表中
           while (head != null) {
               if (head.val < x) {
                   smallTail.next = head;
                   smallTail = smallTail.next;
               } else {
                   largeTail.next = head;
                   largeTail = largeTail.next;
               }
               head = head.next;
           }
           
           // 其 next 指针可能指向一个小于 x 的节点，所以要置空
           largeTail.next = null;
           smallTail.next = largeHead.next;  // 拼接两个链表
           return smallHead.next;
       }
   }
   ```

2. 快速排序 partition 思想。

   ```java
   /**
    * 快速排序 partition 操作思想
    * 时间复杂度: O(N)
    * 空间复杂度: O(1)
    */
   class Solution {
       public ListNode partition(ListNode head, int x) {
           if (head == null) return head;
           
           // 设置虚拟头节点
           ListNode dummyHead = new ListNode(-1);
           dummyHead.next = head;
           // 先跳过初始链表前面所有小于 x 的节点，使得 limit 指向左侧小于 x 区间的最后一个节点
           ListNode limit = dummyHead;   // 分界点
           while (limit.next != null && limit.next.val < x)
               limit = limit.next;
           
           // 开始遍历节点，pre 指向待考察节点的前一个节点
           ListNode pre = limit;  
           while (pre.next != null) {
               if (pre.next.val < x) {  // 如果下一个节点小于 x
                   // 移除下一个节点 removeNode
                   ListNode removeNode = pre.next;
                   pre.next = pre.next.next;
                   // 将 removeNode 拼到前面小于 x 区间的后面
                   removeNode.next = limit.next;
                   limit.next = removeNode;
                   // 更新分界点
                   limit = removeNode;
               } else {
                   pre = pre.next;  // 不小于 x 的直接跳过
               }
           }
           return dummyHead.next;
       }
   }
   ```

> [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)
>
> 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。
>
> 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

1. 分组合并。官方解法。

   ```java
   /**
    * 分离节点后合并
    * 时间复杂度: O(N)
    * 空间复杂度: O(1)
    */
   class Solution {
       public ListNode oddEvenList(ListNode head) {
           if (head == null) return head;
           ListNode evenHead = head.next;   // 偶串头节点
           ListNode odd = head, even = evenHead;  // 奇、偶串尾节点
           // 等于一次移动两个节点
           while (even != null && even.next != null) {
               // 更新奇串尾部
               odd.next = even.next;
               odd = odd.next;
               // 更新偶串尾部
               even.next = odd.next;
               even = even.next;
           }
           odd.next = evenHead;  // 拼接奇偶串
           return head;
       }
   }
   ```

2. partition 思想。

   ```java
   /**
    * 遍历，partition 思想
    * 时间复杂度: O(N)
    * 空间复杂度: O(1)
    */
   class Solution2 {
       public ListNode oddEvenList(ListNode head) {
           if (head == null) return head;
           // 分界点，奇区的最后一个节点
           ListNode lastOdd = head;
           // 待考察节点的前驱节点，是一个偶节点，也是已经排好的最后一个偶节点
           ListNode lastEven = head.next;
           
           while (lastEven != null && lastEven.next != null) {
               // 移除下一个节点 removeNode，是一个奇节点
               ListNode odd = lastEven.next;
               lastEven.next = lastEven.next.next;
               // 将 removeNode 拼到前面小于 x 区间的后面
               odd.next = lastOdd.next;
               lastOdd.next = odd;
               // 更新标记点
               lastOdd = odd;
               lastEven = lastEven.next;
           }
           return head;
       }
   }
   ```

> [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)
>
> 给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。
>
> 请你将两个数相加，并以相同形式返回一个表示和的链表。
>
> 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。



> [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)
>
> 给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
>
> 你可以假设除了数字 0 之外，这两个数字都不会以零开头。
>

# 设立链表的虚拟头结点（移除链表元素）

## 题目分析

> [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)
>
> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

要删除一个元素应该怎么做呢？我们在遍历链表过程中，如果发现当前节点 cur 的下一个节点就是待删除的节点 delNode，我们就执行 `cur.next = delNode.next` 就可以直接跳过待删除节点（可选操作：释放 delNode 空间），如下图所示。

![image-20210830230902920](https://z3.ax1x.com/2021/08/30/hN2plQ.png)

这个操作对 delNode 是最后一个元素同样适用。但是这样的操作对 delNode 是第一个元素是不适用的，因为这套操作的 cur 是 delNode 的前一个节点，如果 `delNode == head`，则 delNode 的前面没有任何元素。对此，我们需要对头节点进行单独操作。

## 代码实现

1. 迭代法，不设置虚拟头节点。

   ```java
   /** 
    * 迭代法
    * 时间复杂度: O(n)
    * 空间复杂度: O(1)
    */
   class Solution {
       public ListNode removeElements(ListNode head, int val) {
           // 删除链表开头所有符合条件的节点
           while (head != null && head.val == val)
               head = head.next;
   
           if (head == null) return head;
   
           // 开始逐个考察节点，删除中间的节点
           ListNode cur = head;
           while (cur.next != null) {
               if (cur.next.val == val) {
                   cur.next = cur.next.next;  // 跨过待删除节点
               } else {
                   cur = cur.next;
               }
           }
   
           return head;
       }
   }
   ```

2. 迭代法，设置虚拟头节点。

   ```java
   /** 
    * 迭代法,设置虚拟头节点
    * 时间复杂度: O(n)
    * 空间复杂度: O(1)
    */
   class Solution {
       public ListNode removeElements(ListNode head, int val) {
           // 设置虚拟头节点
           ListNode dummyHead = new ListNode(0);
           dummyHead.next = head;
   
           // 开始逐个考察节点，删除中间的节点
           ListNode cur = dummyHead;
           while (cur.next != null) {
               if (cur.next.val == val) {
                   cur.next = cur.next.next;  // 跨过待删除节点
               } else {
                   cur = cur.next;
               }
           }
   
           return dummyHead.next;
       }
   }
   ```
   
3. 递归法

   ```java
   // todo
   ```


## 相关问题

> [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)
>
> 存在一个按升序排列的链表，给你这个链表的头节点 `head` ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 **没有重复出现** 的数字。
>
> 返回同样按升序排列的结果链表。
>



> [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
>
> 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 



# 复杂的穿针引线（两两交换链表中的节点）

## 问题分析

> [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)
>
> 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。
>
> ```
> 输入：head = [1,2,3,4]
> 输出：[2,1,4,3]
> ```

如下图，交换每一对元素，以 (1,2) 为例，交换完位置后，应该让 `pre(1) -> 2 -> 1 -> next(2)`，其中 pre(1) 表示 1 的前一个节点，next(2) 表示 2 的后一个节点。过程中我们需要知道 pre(1) 是谁，但是头节点 head 没有前一个节点。这种情况下我们又要对头节点作特殊处理，为了避免这种特殊处理我们需要设置虚拟头节点。

![image-20210831084457840](https://z3.ax1x.com/2021/08/31/hUFS9x.png)

在设置了虚拟头节点后，我们需要将 `pre(1) -> 2`，所以我们设置一个指针 p 表示需要交换的一对节点之前的一个节点。另外还需要两个指针指向待交换的两个节点 node1、node2，此外还需要让 `1 -> next(2)`，所以还需要一个指针 next 指向待交换的两个节点的下一个节点。

![image-20210831085322135](https://z3.ax1x.com/2021/08/31/hUFU2V.png)

有了这 4 个指针，我们只需要执行如下操作即可。

```java
node2.next = node1;  // node2 指向 node1
node1.next = next;   // node1 执行后续节点
p.next = node2;      // 前节点指向 node2
```

此时这一对节点就完成交换了，此时我们还需要将 p 指针指向 node1，也就是下一对待交换节点之前的节点，然后根据 p 重新定义 node1、node2 和 next，重复上述操作即可。

## 代码实现

1. 迭代

   ```java
   /**
    * 迭代法
    * 时间复杂度: O(n)
    * 空间复杂度: O(1)
    */
   class Solution {
       public ListNode swapPairs(ListNode head) {
           // 设置虚拟头节点
           ListNode dummyHead = new ListNode(0);
           dummyHead.next = head;
   
           ListNode p = dummyHead;  // pre 指向待交换节点的前一个节点
           while (p.next != null && p.next.next != null) {
               // 记录要交换的两个节点和后续节点
               ListNode node1 = p.next;
               ListNode node2 = node1.next;
               ListNode next = node2.next;
               // 进行交换操作
               node2.next = node1;
               node1.next = next;
               p.next = node2;
               // 更新 pre
               p = node1;
           }
   
           return dummyHead.next;
       }
   }
   ```

2. 递归

   ```java
   // todo
   ```

## 相关问题

> [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)
>
> 给你一个链表，每 *k* 个节点一组进行翻转，请你返回翻转后的链表。
>
> *k* 是一个正整数，它的值小于或等于链表的长度。
>
> 如果节点总数不是 *k* 的整数倍，那么请将最后剩余的节点保持原有顺序。
>



> [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)
>
> 对链表进行插入排序。
>
> 插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
> 每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。



> [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)
>
> 给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。



# 不仅仅是穿针引线（删除链表中的节点）

之前我们介绍的链表问题都是在链表中穿针引线，不过有时候我们的思路要灵活些，有的链表问题不仅仅是穿针引线。

> [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)
>
> 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 **要被删除的节点** 。

这个问题和之前一个删除节点的问题很相似，但是要注意的是这个问题的传入参数是 **要被删除的节点**，并不是头节点和待删除节点。如下图，如果要删除节点 3，函数入参只有节点 3，我们拿不到 3 的前一个节点。

![image-20210831090253404](https://z3.ax1x.com/2021/08/31/hUkcwQ.png)

之前我们说过一般不能操作节点中的 val，但是这个问题只能这么作。我们把节点 4 的值赋给 3，然后 `node.next = node.next.next` 跨过原节点 4 即可。

```java
/**
 * 时间复杂度: O(1)
 * 空间复杂度: O(1)
 */
class Solution {
    public void deleteNode(ListNode node) {
        if (node == null || node.next == null) {
            node = null;
            return;
        }

        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```

# 链表与双指针（删除链表的倒数第 N 个结点）

## 问题分析

我们曾经在研究数组问题的时候介绍过双指针技术，链表中有时候也可以通过定义双指针解决问题。

> [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)
>
> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

1. 计算链表长度

   先遍历一遍计算链表长度 l，再遍历一遍删除倒数第 n 个节点，即正数第 l-n 个节点。

   ```java
   /**
    * 计算链表长度
    * 时间复杂度: O(n)
    * 空间复杂度: O(1)
    */
   class Solution2 {
       public ListNode removeNthFromEnd(ListNode head, int n) {
           ListNode dummyHead = new ListNode(0);
           dummyHead.next = head;
           // 计算链表长度
           int length = 0;
           for (ListNode cur = dummyHead.next; cur != null; cur = cur.next)
               length++;
           // 计算待删除元素是整数第几个
           int k = length - n;
           ListNode cur = dummyHead;
           for (int i = 0; i < k; i++)
               cur = cur.next;
           // 删除元素
           cur.next = cur.next.next;
           return head;
       }
   
   }
   ```

2. 虚拟头节点 + 滑动窗口

   解法2：如下图所示，设置虚拟头节点，然后定义一个窗口 [p,q]，初始 p 指向虚拟头节点，q 和 p 中间隔 n 个节点，即 q 指向 p 经过 n+1 次 next 后指向的节点。然后 p、q 同事右移直到 q 到了 null 位置，此时 p 就指向待删除节点的前一个节点了。

   ![image-20210831131744021](https://z3.ax1x.com/2021/08/31/hU71XV.png)

   ```java
   /**
    * 虚拟头节点 + 滑动窗口
    * 时间复杂度: O(n)
    * 空间复杂度: O(1)
    */
   class Solution {
       public ListNode removeNthFromEnd(ListNode head, int n) {
           // 设置虚拟头节点
           ListNode dummyHead = new ListNode(0);
           dummyHead.next = head;
           // 设置滑动窗口
           ListNode l = dummyHead;
           ListNode r = dummyHead;
           for (int i = 0; i < n + 1; i++)
               r = r.next;
           // 窗口右滑直到右边界到 null
           while (r != null) {
               l = l.next;
               r = r.next;
           }
           // 跨过待删除节点
           l.next = l.next.next;
           
           return dummyHead.next;
       }
   }
   ```

## 相关问题

> [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)
>
> 给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。



> [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)
>
> 给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为： `L0 → L1 → … → Ln-1 → Ln`
>
> 请将其重新排列后变为： `L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …`
>
> 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
>



> [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)
>
> 给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。
>
> **进阶：**你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？

