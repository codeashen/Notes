# 贪心基础 Assign Cookies

## 问题分析

贪心算法通常是实现起来非常简单的一类算法，通常贪心算法的代码会非常短，而且思路也非常简单，贪心算法真正的难点在于确定当前问题可以使用贪心算法。下面先来看一个简单的贪心算法问题。

> [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)
>
> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>
> 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>

在本题中，为了尽可能让更多的孩子满足，可以尝试将最大的饼干给胃口最大的孩子，如果最大的饼干可以满足胃口最大的孩子，我们留给下一个胃口次大的孩子的饼干也将是当前看来最大的饼干，相当于我们对饼干留了一个富裕。另一方面，如果最大的饼干都无法满足胃口最大的孩子，那所有的饼干都不能满足他，这种情况只能尝试让最大的饼干满足胃口次大的孩子。这样的每次都尝试当前剩下的最大的饼干满足胃口最大的孩子，能最大程度保证最多的孩子满足。

根据这样的思路，实现起来也并不难，不过实现这样一个算法必须要将饼干大小数组和孩子胃口值数组排序。其实贪心算法永远牵扯到我们每一次都要取最大值或者最小值这样的操作，所以通常实现贪心算法和排序是分不开的。所以如果题目没有说数组是有序的，我们就要先进行排序。

## 代码实现

1. 尝试先满足最胃口值最大的孩子

   ```java
   /**
    * 先尝试满足最胃口大的孩子
    * 时间复杂度: O(nlogn)
    * 空间复杂度: O(1)
    *
    * @param g 胃口值数组
    * @param s 饼干数组
    * @return 返回最多满足孩子数
    */
   public int findContentChildren1(int[] g, int[] s) {
       // 胃口值和饼干大小排序
       Arrays.sort(g);
       Arrays.sort(s);
   
       // gi、si 分别指向最大胃口值和最大饼干
       int gi = g.length - 1;
       int si = s.length - 1;
   
       int res = 0;  // 已经满足的孩子数量
       while (gi >= 0 && si >= 0) {
           if (s[si] >= g[gi]) {
               // 如果饼干可以满足当前孩子，res 加一，继续考察下一个饼干和孩子
               res++;
               gi--;
               si--;
           } else {
               // 如果没法满足，则所有的饼干都没法满足，跳过这个孩子
               gi--;
           }
       }
   
       return res;
   }
   ```

2. 尝试先满足最胃口值最小的孩子

   ```java
   /**
    * 先尝试满足最胃口小的孩子
    * 时间复杂度: O(nlogn)
    * 空间复杂度: O(1)
    *
    * @param g 胃口值数组
    * @param s 饼干数组
    * @return 返回最多满足孩子数
    */
   public int findContentChildren2(int[] g, int[] s) {
       // 胃口值和饼干大小排序
       Arrays.sort(g);
       Arrays.sort(s);
   
       // gi、si 分别指向最大胃口值和最大饼干
       int gi = 0;
       int si = 0;
   
       int res = 0;  // 已经满足的孩子数量
       while (gi < g.length && si < s.length) {
           if (s[si] >= g[gi]) {
               // 如果饼干可以满足当前孩子，res 加一，继续考察下一个饼干和孩子
               res++;
               gi++;
               si++;
           } else {
               // 如果没法满足，则这块饼干没法满足任何孩子，跳过这块饼干
               si++;
           }
       }
   
       return res;
   }
   ```

## 相关问题

> [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)
>
> 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
>

# 贪心算法与动态规划的关系

## 问题描述 Non-overlapping Intervals

贪心算法和动态规划看似不相干，其实有着挺密切的关系，这一节我们通过一个问题看看贪心算法和动态规划的关系。

> [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)
>
> 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
>
> 注意:
>
> - 可以认为区间的终点总是大于它的起点。
> - 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

这个问题问的是最少删除多少个区间，我们可以将问题看作是最多保留多少个区间，使得这些区间互相不重叠。还是一样，当我们没有思路的时候不妨先想想暴力解法如何解决。

暴力解法：找出所有子区间的组合，之后判断它不重叠。时间复杂度是 O((2^n)*n)，其中 2^n 是指对于每一个区间都可以选择留下或者不留下，这样给给定了一组 n 个区间的话，就有 2^n 种组合，最后有 O(n) 的时间复杂度判断是否重叠。

先要对区间排序，才能方便判断是否有重叠。对于区间来说，通常按照起始点进行排序。

经过上面分析我们发现这又是一个组合问题，对于组合问题我们可以思考是否可以使用动态规划来解决。我们对这些区间排好序之后现在在这些区间中保留对多的区间使得他们互相不重叠，这件事像极了最长上升子序列，我们每次对每个区间 i 都可以回头看它前面的所有区间，看是否可以跟在前面某个区间的后面，如果可以，前面区间的最大不重叠区间数加 1，就是包含区间 i 的不重叠区间数。在这些可以接上的所有的不重叠区间数中取出最大的加 1 就是以区间 i 结尾的最大不重叠区间数。

## 代码实现























# 贪心选择性质的证明