### 一、聚合分析概述

搜索引擎用来回答如下问题：

- 请告诉我地址为上海的所有订单？
- 请告诉我最近1天内创建但没有付款的所有订单？

聚合分析可以回答如下问题：

- 请告诉我最近1周每天的订单成交量有多少？
- 请告诉我最近1个月每天的平均订单金额是多少？
- 请告诉我最近半年卖的最火的前5个商品是哪些？

**聚合分析（Aggregation）**，是 es 除搜索功能外提供的针对 es 数据做统计分析的功能

* 功能丰富，提供 Bucket、Metric、Pipeline 等多种分析方式，可以满足大部分的分析需求
* 实时性高，所有的计算结果都是即时返回的，而 hadoop 等大数据系统一般都是 T+1 级别的

聚合分析作为 search 的一部分，api 如下所示：

![image-20201228223957382](https://s3.ax1x.com/2020/12/29/rquUlF.png)

例：请告诉我公司目前在职人员工作岗位的分布情况？

![image-20201228224118476](https://s3.ax1x.com/2020/12/29/rquay4.png)

为了便于理解，es将聚合分析主要分为如下4类

* **Bucket**，分桶类型，类似SQL中的GROUP BY 语法
* **Metric**，指标分析类型，如计算最大值、最小值、平均值等等
* **Pipeline**，管道分析类型，基于上一级的聚合分析结果进行再分析
* Matrix，矩阵分析类型

### 1.7.2 Metric聚合分析

主要分如下两类：

* 单值分析，只输出一个分析结果
    * min，max，avg，sum
    * cardinality
* 多值分析，输出多个分析结果
    * stats，extended stats
    * percentile，percentile rank
    * top hits

#### min

单值分析以min为例，返回数值类字段的最小值，max、avg、sum 同理

![image-20201228224800852](https://s3.ax1x.com/2020/12/29/rqu0m9.png)

一次返回多个聚合分析：

![image-20201228225104133](https://s3.ax1x.com/2020/12/29/rquBwR.png)

#### cardinality

Cardinality，意为集合的势，或者基数，是指不同数值的个数，类似SQL中的distinct count 概念

![image-20201228225315162](https://s3.ax1x.com/2020/12/29/rqusFx.png)

#### stats

返回一系列数值类型的统计值，包含min、max、avg、sum和count

![image-20201228225439558](https://s3.ax1x.com/2020/12/29/rquyY6.png)

#### entended stats

对stats的扩展，包含了更多的统计数据，如方差、标准差等

![image-20201228225556165](https://s3.ax1x.com/2020/12/29/rqu2lD.png)

#### percentile

百分位数统计

![image-20201228225805803](https://s3.ax1x.com/2020/12/29/rquR6e.png)

以上响应表示，1.0%的数据在5150以内，95.5%的数据在26250以内

#### percentile rank

百分位数统计

![image-20201228225948207](https://s3.ax1x.com/2020/12/29/rquhmd.png)

以上示例表示，11000工资在50%的位置，30000工资在75%的位置

#### top hit

一般用于分桶后获取该桶内最匹配的顶部文档列表，即详情数据

![image-20201228230214811](https://s3.ax1x.com/2020/12/29/rqu7ff.png)

上述请求表示，现根据job名称分组，然后对每个job组中的数据取年龄在前10名的，根据年龄倒序排列。（就像是公司裁员，每个岗位取10个年纪最大的，干掉）

### 1.7.3 Bucket聚合分析

Bucket，意为桶，即按照一定的规则将文档分配到不同的桶中，达到分类分析的目的

![image-20201228230737559](https://s3.ax1x.com/2020/12/28/r7al7D.png)

按照Bucket的分桶策略，常见的Bucket聚合分析如下：

* Terms
* Range
* Date Range
* Histogram
* Date Histogram

#### Terms

该分桶策略最简单，直接按照term来分桶，如果是text类型，则按照分词后的结果分桶

![image-20201228230938657](https://s3.ax1x.com/2020/12/28/r7abg1.png)

#### Range

通过指定数值的范围来设定分桶规则

![image-20201228231154222](https://s3.ax1x.com/2020/12/30/rq8cE4.png)

#### Date Range

通过指定日期的范围来设定分桶规则

![image-20201228231400377](https://s3.ax1x.com/2020/12/30/rq8WCR.png)

#### Histogram

直方图，以固定间隔的策略来分割数据

![image-20201228231532484](https://s3.ax1x.com/2020/12/30/rq8f81.png)

#### Date Histogram

针对日期的直方图或者柱状图，是时序数据分析中常用的聚合分析类型

![image-20201230002833090](https://s3.ax1x.com/2020/12/30/rq8HVe.png)

#### Bucket + Metric 聚合分析

Bucket 聚合分析允许通过添加子分析来进一步进行分析，该子分析可以是Bucket也可以是Metric。这也使得es的聚合分析能力变得异常强大

例一：分桶后再分桶

![image-20201230003127395](https://s3.ax1x.com/2020/12/30/rqGSr8.png)

例二：分桶后进行数据分析

![image-20201230003513621](https://s3.ax1x.com/2020/12/30/rqGeMV.png)

### 1.7.4 Pipeline聚合分析

针对聚合分析的结果再次进行聚合分析，而且支持链式调用。

可以回答如下问题：订单月平均销售额是多少？

![image-20201230003832151](https://s3.ax1x.com/2020/12/30/rqGwIH.png)

上述聚合示例有3步

```
1. 根据月份分桶，分到每个月份的营业额集合（sales_per_month）
2. 对分桶的结果进行求和分析，计算出每个月的营业总额（sales）
3. 对每月的营业总额求平均值（avg_monthly_sales，分析的是sales_per_month>sales下的结果）
```

Pipeline的分析结果会输出到原结果中，根据输出位置的不同，分为以下两类：

1. **Sibling**：结果与现有聚合分析结果同级
2. **Parent**：结果内嵌到现有的聚合分析结果中

#### Sibling Pipeline

Sibling Pipeline聚合结果与现有聚合分析结果同级，有以下几种聚合方式：

| 聚合方式                                                   | 作用                 |
| ---------------------------------------------------------- | -------------------- |
| max_bucket <br/>min_bucket <br/>avg_bucket <br/>sun_bucket | 求最值、平均值、求和 |
| stats_bucket <br/>extended_stats_bucket                    | 一系列统计数         |
| percentiles_bucket                                         | 百分位数统计         |

**(1) min_bucket**

找出所有Bucket中值最小的Bucket名称和值

![image-20201230005437480](https://s3.ax1x.com/2020/12/30/rqJ0mT.png)

以上示例表示：按job类型分组，求出每种job的平均工资，同时得出平均工资最少的一个桶

> 注意：这里请求的聚合名里，`avg_salary`在`jobs`里面，而`min_salary_by_job`和外层的`jobs`同级

min_bucket、avg_bucket、sun_bucket用法类似

**(2) stats_bucket**

计算所有Bucket值的Stats分析

![image-20201230011325095](https://s3.ax1x.com/2020/12/30/rqYnN4.png)

**(3) percentiles_bucket**

计算所有Bucket值的百分位数

![image-20201230011512936](https://s3.ax1x.com/2020/12/30/rqYQ3R.png)

#### Parent Pipeline

Parent Pipeline聚合结果内嵌到现有的聚合分析结果中，有以下几种方式：

| 聚合方式       | 作用       |
| -------------- | ---------- |
| derivative     | 导数       |
| moving_avg     | 移动平均值 |
| cumulative_sum | 累积加和   |

**derivative**

计算Bucket值的导数

![image-20201230012107933](https://s3.ax1x.com/2020/12/30/rqYsDf.png)

>  注意：这里请求的聚合名里，`avg_salary`在`birth`里面，而`derivative_avg_salary`和内层的`avg_salary`同级，也在`birth`里面

moving_avg、cumulative_sum用法类似

### 1.7.5 作用范围

es聚合分析默认作用范围是query的结果集，可以通过如下的方式改变其作用范围

1. filter
2. post_filter
3. global

![image-20201230012957015](https://s3.ax1x.com/2020/12/30/rqtSr6.png)

#### 作用范围 filter

为某个聚合分析设定过滤条件，从而在不更改整体 query 语句的情况下修改了作用范围

![image-20201230013252648](https://s3.ax1x.com/2020/12/30/rqtAGd.png)

上述例子总体有两个聚合分析，`jobs_salary_small`和`jobs`，两个聚合分析针对不同的query条件聚合分析。

`jobs`根据主查询分析，即没限制查询条件的所有文档

`jobs_salary_small`在主查的基础上，增加了`filter`条件，只分析工资范围是*-10000的文档数据

所以结果`jobs`聚合组有4个bucket，`jobs_salary_small`聚合组只有工资少于10000的两个bucket

#### 作用范围 post-filter

作用于文档过滤，但在聚合分析后生效

![image-20201230014319487](https://s3.ax1x.com/2020/12/30/rqNCyq.png)

上述示例中，结果是先针对所有文档进行聚合分析，但是得到分析结果之后，会将著查询的`hits`结果按照`post_filter`的规则过滤，所以`jobs`分析的结果中有所有的bucket，但是著查询`hits`结果中只有一个文档

#### 作用范围 global

无视 query过滤条件，基于全部文档进行分析

![image-20201230014742832](https://s3.ax1x.com/2020/12/30/rqNK61.png)

上述示例中，有两个聚合分析，`java_avg_salary`和`all`，`java_avg_salary`基于著查询`query`进行聚合分析，`all`设置`global`，无视主查询的query条件，对所有文档进行分析
