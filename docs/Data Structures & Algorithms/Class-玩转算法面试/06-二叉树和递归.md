# 二叉树天然的递归结构

## 问题分析

二叉树是天然的递归结构，它的左子树也是二叉树，右子树也是二叉树，并且没有递归终止条件，并且空也是二叉树。

> [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
>
> 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

1. 深度优先遍历（递归）

   ```java
   /**
    * 深度优先遍历（递归）
    * 时间复杂度: O(n)
    * 空间复杂度: O(height)
    */
   class Solution {
       public int maxDepth(TreeNode root) {
           if (root == null) 
               return 0;
           return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
       }
   }
   ```

2. 广度优先遍历（队列）

   ```java
   /**
    * 广度优先遍历（队列）
    * 时间复杂度: O(n)
    * 空间复杂度: 取决于队列中存储的元素，最快 O(n)
    */
   class Solution2 {
       public int maxDepth(TreeNode root) {
           if (root == null) return 0;
           int depth = 0;
           
           Queue<TreeNode> queue = new LinkedList<>();
           queue.offer(root);
           while (!queue.isEmpty()) {
               int size = queue.size();
               for (int i = 0; i < size; i++) {
                   TreeNode node = queue.poll();
                   if (node.left != null) queue.offer(node.left);
                   if (node.right != null) queue.offer(node.right);
               }
               depth++;
           }
           return depth;
       }
   }
   ```

## 相关问题

> [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)
>
> 给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

# 一个简单的二叉树问题引发的血案（翻转二叉树）

## 问题分析

> [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)
>
> 翻转一棵二叉树。

```java
/**
 * 递归翻转二叉树
 * 时间复杂度: O(n)
 * 空间复杂度: O(n)
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null)
            return root;

        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        root.left = right;
        root.right = left;
        return root;
    }
}
```

## 相关问题

> [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)
>
> 给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。
>
> 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。



> [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)
>
> 给定一个二叉树，检查它是否是镜像对称的。



> [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)
>
> 给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。
>
> [完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。
>
> **进阶：**遍历树来统计节点是一种时间复杂度为 `O(n)` 的简单解决方案。你可以设计一个更快的算法吗？



> [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)
>
> 给定一个二叉树，判断它是否是高度平衡的二叉树。
>
> 平衡二叉树：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
>



# 注意递归的终止条件（路径总和）

## 问题分析

对于递归函数很重要的一点就是找到递归终止条件，这里看一个终止条件稍微复杂的题目。

> [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)
>
> 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` ，判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。

1. 深度优先遍历（递归）

   这道题适用递归的思想很简单，递归结构为在根节点 `root` 中查找左右孩子查找是否有 `sum - root.val` 的路径。

   ```java
   /**
    * 递归
    * 时间复杂度: O(n)
    * 空间复杂度: O(h)，最坏链条 O(n)，平均 O(logn)
    */
   class Solution {
       public boolean hasPathSum(TreeNode root, int targetSum) {
           if (root == null)
               return false;
           // 判断是不是叶子节点
           if (root.left == null && root.right == null) {
               return targetSum == root.val;
           } else {
               return hasPathSum(root.left, targetSum - root.val)
                       || hasPathSum(root.right, targetSum - root.val);
           }
       }
   }
   ```

2. 广度优先遍历

   ```java
   // todo
   ```

## 相关题目

> [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)
>
> 计算给定二叉树的所有左叶子之和。



# 定义递归问题（二叉树的所有路径）

前面递归相关题目的逻辑部分都很简单，这一节来看一下逻辑略微复杂一些的题目。在这个问题中大家也可以体会下如何利用递归函数的返回值。

> [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)
>
> 给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。
>
> ![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)
>
> **输入：**root = [1, 2, 3, null, 5]  **输出：**["1->2->5", "1->3"]

这个问题的递归结构也很简单，我们要找从 `root` 出发的所有路径，只需要找到左右子树的所有路径，然后前面加上 `root.val->` ，并合并两组路径即可。这里我们要注意递归终止条件是到达了叶子节点就返回路径，递归的返回值是 **路径数组**。

1. 深度优先遍历（递归）

   这道题适用递归的思想很简单，递归结构为在根节点 `root` 中查找左右孩子查找是否有 `sum - root.val` 的路径。

   ```java
   /**
    * 深优先限遍历（递归）
    * 时间复杂度: O(n), n为树中的节点个数
    * 空间复杂度: O(h), h为树的高度
    */
   class Solution {
       public List<String> binaryTreePaths(TreeNode root) {
           List<String> res = new ArrayList<>();
           if (root == null) 
               return res;
           // 如果是叶子节点，递归结束
           if (root.left == null && root.right == null) {
               res.add(String.valueOf(root.val));
               return res;
           }
           // 不是叶子节点，获取左右子树结果，并处理合并
           List<String> leftRes = binaryTreePaths(root.left);
           List<String> rightRes = binaryTreePaths(root.right);
           for (String item : leftRes)
               res.add(root.val + "->" + item);
           for (String item : rightRes)
               res.add(root.val + "->" + item);
           
           return res;
       }
   }
   ```

2. 广度优先遍历

   ```java
   // todo
   ```

## 相关问题

> [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)
>
> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。
>
> ```
> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 
> 输出：[[5,4,11,2],[5,8,4,5]]
> ```



> [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)
>
> 给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。
>
> 每条从根节点到叶节点的路径都代表一个数字：
>
> - 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。
>
> 计算从根节点到叶节点生成的 **所有数字之和** 。
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)
>
> ```
> 输入：root = [1,2,3]
> 输出：25
> ```

 

# 稍复杂的递归逻辑（路径总和 III）

> [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)
>
> 给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。
>
> **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
>
> ![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)
>
> ```
> 输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
> 输出：3
> 解释：和等于 8 的路径有 3 条，如图所示。
> ```









# 二分搜索树中的问题 Lowest Common Ancestor of a Binary Search Tree