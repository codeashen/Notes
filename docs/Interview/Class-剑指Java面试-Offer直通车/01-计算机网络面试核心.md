# 一、网络基础

## OSI 七层网络模型

国际标准化组织 ISO 制定的 OSI 七层协议模型是业界提出来的概念型框架，是不断迭代出来的，下面看看七层协议是如何进化来的。

![](https://img-blog.csdnimg.cn/2021010409370574.gif)

我们首先要解决两台物理机之间的通信需求，具体就是机器 A 往机器 B 发送比特流，机器 B 能收到这些比特流，这便是物理层要做的事情。物理层主要定义了物理设备的标准，有网线的类型，光纤的接口类型，各种传输介质的传输速率等。它的主要作用，是传输比特流即我们所谓的 0101 二进制数据，让他们转化为电流强弱来进行传输，到达目的地后再转化为的机器码，也就是我们常说的数模转换与模数转换，这层的数据叫做比特。网卡就是工作在这一层里面的。

第二层是数据链路层，在传输比特流的过程中会产生错传、数据传输不完整的可能，因此数据链路层应运而生。数据链路层定义了如何格式化数据进行传输，以及如何控制对物理介质的访问，这一层，通常还提供错误检测和纠正，以确保数据传输的可靠性。本层将比特数据组成了帧，其中，交换机工作在这一层里面，会帧解码，并根据帧中包含的信息把数据发送到正确的接收方。

那随着网络节点的不断增加，点对点通信的时候是需要经过多个节点的，那么如何找到目标节点，如何选择最佳路径便成为了首要需求，此时便有了网络层。这是我们的第三层，将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接受方。综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费，来决定从一个网络中节点 A 到另一个网络中节点B的最佳路径。由于网络层处理并智能指导数据传送，路由器连接网络各段，所以路由器属于网络层，此层的数据我们称之为数据包，本层我们需要关注的协议主要是 TCP/IP 协议里的IP协议。

那么随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输的可能需要很长时间，而网络在通信的过程中会中断好多次，此时为了保证传输大量文件时的准确性，需要对发出去数据进行切分，切割为一个一个的段落即 segment 进行发送，那么其中一个段落丢失了该怎么办？要不要重传？每个段落要按照顺序到达吗？这个便是传输层需要考虑的问题了。传输层解决了主机间的数据传输，数据间的传输可以是不同网络的，并且解决了传输质量的问题，称之为 OSI 模型中最重要的一层。传输协议同时进行流量控制，或是基于接收方可接收数据的快慢程度规定适当的发送速率，除此之外，传输层按照网络能处理的最大尺寸，将较强的数据包进行强制分割，例如以太网无法接收大于 1500 字节的数据包，发送方节点的传输层，将数据呢分割成较小的数据片，同时对每一数据片安排序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组，该过程即称为排序传输。传输层中需要关注的协议有 TCP/IP 协议中的 TCP 协议和 UDP 协议。

现在我们已经保证给正确的计算机发送正确的封装过后的信息了，但是用户级别的体验好不好，难道我每次都要去调用 TCP 去打包，然后就要用 IP 协议去找路由自己去发？当然不行，所以我们要建立一个自动收发包、自动寻址的功能，于是发明了会话层。会话层的作用，就是建立和管理应用程序之间的通信。

现在我能保证应用程序自动收发包和自动寻址了，但我要用 Linux 给 windows 发包，两个系统语法不一致，于是需要表示层帮我们解决不同系统之间的通信语法的问题，在表示层将数据将按照网络能理解的方案进行格式化，这种格式化也因所使用网络的类型不同而不同。

此时，虽然发送方知道自己发送的是什么东西转化成字节数据之后有多长，但接收方肯定不知道，所以应用层的网络协议诞生了，它规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，而且消息投影必须记录消息体的长度等一系列信息，以方便接收方能够正确的解析发送方发送的数据。应用层旨在让你更方便的应用从网络中接收到的数据，至于数据的传递，没有该层你也可以直接在两台电脑间开干，只不过传来传去就是1和0组成的字节数组。该层需要我们重点去关注的是 TCP/IP 协议中的 HTTP 协议。

![](https://z3.ax1x.com/2021/07/09/RjejVx.png)

以上就是关于 OSI 各层次的划分，那从应用层开始都会对要传输的数据头部进行处理，加上本层的一些信息，最终由物理层通过以太网电缆等介质，将数据解析成比特流在网络中传输。数据传递到目标地址，并自底而上的将先前对应层的头部给解析分离出来，这个就是我们的网络数据处理的整个流程。

## TCP/IP 四层网络模型

OSI 是一个定义良好的协议规范级，并有许多可选部分完成类似的任务，它定义了开放系统的层次，结构层次之间的相互关系以及各层所包括的可能的任务，是作为一个框架来协调和组织各层所提供的服务。但是 OSI 参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的制定。 即 OSI 参考模型，并不是一个标准，而是一个在制定标准时所使用的概念性框架。事实的标准是 TCP/IP 四层架构参考模型。

![](https://img-blog.csdn.net/20170822222325781)

TCP/IP 参考模型是计算机网络的祖父ARPANET和其后继的因特网使用的参考模型，市面上绝大多数厂商也以该标准为主，该模型并不完全符合 OSI 的七层参考模型，但我们依然可以理解为它是 OSI 的一种实现。接下来咱们来讲讲这个主流的协议。

从字面上讲，有人可能会认为， TCP/IP 是指TCP和IP这两种协议，实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用IP进行通信时所必须用到的协议群的统称，具体来说IP、icmp、TCP、udp、telnet或者FTP，都属于 TCP/IP 协议。 TCP/IP 与 OSI 在分层模块上稍有区别， TCP/IP 的应用程序可以理解为约等于 TCP/IP 中的应用层、表示层和会话层的组合，同时 OSI 的数据链路层以及物理层在 TCP/IP 中被规定为链路层。 OSI 模型注重通信协议必要的功能是什么，而 TCP/IP 则更强调在计算机上实现协议应该开发哪种程序。

![](https://img-blog.csdn.net/20160802112022872)

从另外一张图里，在数据传输的过程中，我们可以看到和 OSI 一样， TCP/IP 的每个过程中，都会对所发送的数据附加一个头部，在这个头部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常为协议提供的信息为报头的头部，所要发送的内容为数据。从下一层角度上看，数据被传送到接收端之后，再层层解套出来。

## 参考

- [ OSI 七层模型详解](https://blog.csdn.net/yaopeng_2005/article/details/7064869)
- [ TCP/IP 四层模型](https://blog.csdn.net/csdn_kou/article/details/82910753)
- [ OSI 七层协议模型、 TCP/IP 四层模型和五层协议体系结构之间的关系](https://blog.csdn.net/wxb880114/article/details/82751680)
- [ OSI 七层模型与 TCP/IP 五层模型](https://www.cnblogs.com/qishui/p/5428938.html)

# 二、TCP 三次握手

## 传输控制协议 TCP 简介

- 面向连接的、可靠的、基于字节流的传输层通信协议
- 将应用层的数据流分割成报文段并发送给目标节点的 TCP 层
- 数据包都有序号， 对方收到则发送 ACK 确认， 未收到则重传
- 使用校验和来检验数据在传输过程中是否有误

## TCP 报文头部

![image-20210819020841734](https://z3.ax1x.com/2021/08/19/f76ASg.png)

- Source Port 、Destination Port：分别表示原端口和目的端口
- Squence Number：序列号
- Acknowledgment Number：确认号
- Offset：数据便宜，由于头部有可选字段，长度不固定，因此它指出 TCP 报文的数据距离 TCP 报文的起始处有多远
- Reserved：保留域
- TCP Flags
  - URG：紧急指针标志
  - ACK：确认序号标志
  - PSH：push 标志
  - RST：重置连接标志
  - SYN：同步序号，用于建立连接过程
  - FIN：finish 标志，用于释放连接
- Window：滑动窗口的大小，用来告知发送端接收端的缓存大小，依次控制发送端发送数据的速率，从而达到流量控制
- Checksum：检验和，有发送端进行存储，并由接收端进行验证
- Urgent Pointer：紧急指针，只有当 TCP Flags 中的 URG 为 1 时才有效，指出本报文段中紧急数据的字节数
- TCP Opions：可选项，其长度可变，定义一些其他的可选参数

## 三次握手过程

![image-20210819024919532](https://z3.ax1x.com/2021/08/19/f7cE4K.png)

在 TCP/IP 协议中, TCP 协议提供可靠的连接服务,采用三次握手建立一个连接。

1. 第一次握手：建立连接时,客户端发送 SYN 包（syn=j）到服务器，并进入 SYN-SEND 状态，等待服务器确认；
2. 第二次握手：服务器收到 SYN 包，必须确认客户的 SYN（ack-j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；
3. 第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK（ack-k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。

## 为什么需要三次握手才能建立起连接

为了初始化 Sequence Number（序列号）的初始值，双方都会生成自己的 Sequence Number，并需要告知对方，作为以后通讯的序号，以保证在网络传输过程，不会因为网络原因而导致乱序。

## 首次握手的隐患 - SYN 超时

问题起因分析：

Server 收到 Client 的 SYN 回复 SYN-ACK，如果此时 Client 掉线或者异常未发出 ACK，Server 没有收到 ACK 确认，那么这个连接就会处于一个中间状态，既没有成功也没有失败。Server 就会不断重发 SYN-ACK 直至超时，Linux 下默认重试 5 次，间隔时间初次为 1s，之后每次都翻倍，5 次失败后总共需要等待 63 秒才断开连接。

这种情况使服务器可能会遭到 SYN Flood 攻击的风险，恶意程序向服务器发送 SYN 报文，然后就下线了，服务器需要等 63s 才会断开连接，这样攻击者就能将服务器的 SYN 连接队列耗尽，使服务器不能处理正常的连接请求。

针对 SYN Flood 的防护措施：

Linux 下提供了一个 `tcp_syncookies` 的参数，当 SYN 队列满后，TCP 会通过源地址端口、目标地址端口和时间戳打造出一个特别的 Squence Number 回发回去，简称 SYN Cookie。如果是攻击者，是不会有相应的，如果是正常连接，则会把 SYN Cookie 发回来，服务端可以通过 Cookie 直接建立连接。通过 SYN Cookie，即便 SYN 队列满了，本次连接请求不在队列中，依然可以建立连接。

## 建立连接后, Client 出现故障怎么办

TCP 设有保活机制，若在在一段时间内连接处于非活动状态，开启保活功能的一端将向对方发送保活探测报文，如果未收到响应则继续发送，直到尝试次数达到保活探测数仍未收到响应，则中断连接。

# 三、TCP 四次挥手

## 四次挥手过程

![image-20210819024831703](https://z3.ax1x.com/2021/08/19/f7cAN6.png)

TCP 采用四次挥手来释放连接，数据传输完毕之后，双方都可以释放连接，这里以客户端主动关闭为例。

1. 第一次挥手：Client 发送一个 FIN，用来关闭 Client 到 Server 的数据传送，Client 进入 FIN_ WAIT_1状态；
2. 第二次挥手：Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为收到序号 +1（与 SYN 相同，一个 FIN  占用一个序号），Server 进入 CLOSE_WAIT 状态；
3. 第三次挥手：Server 发送一个 FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态；
4. 第四次挥手：Client 收到 FIN 后，Client 进入 TIME_WAIT 状态，接着发送一个 ACK 给 Server，确认序号为收到序号 +1，Server 进入 CLOSED 状态，完成四次挥手。

注意，Client 发送最后一次 ACK 后，并没有直接进入关闭状态，二是 TIME-WAIT，时间是 2MSL。MSL，即最长报文段生命。而 Server 端收到 Client 的最后一次 ACK 后就直接关闭连接了。

## 为什么会有 TIME WAIT 状态

主要有两个原因：

- 确保有足够的时间让对方收到 ACK 包。如果被动关闭放没有收到最后一次 ACK，就会触发重发 FIN 包，一来一去正好是两个 MSL。
- 避免新旧连接混淆。因为有些路由器会缓存 IP 数据包，如果连接被重用了，那么这些延迟收到的包就有可能跟新连接混在一起。

## 为什么需要四次握手才能断开连接

因为全双工允许数据在两个方向上同时传输，即在同一时间，客户端可以发送数据给服务端，服务端也可以发送数据给客户端。因为 TCP 是全双工的，要保证数据都传输完了，发送方和接收方都需要 FIN 报文和 ACK 报文，也就是发送方和接收到各需要两次挥手。

## 服务器出现大量 CLOSE_WAIT 状态的原因

对方关闭 socket 连接，我方忙于读或写，没有及时关闭连接。碰到这种情况，多数是因为程序有 bug。

- 检查代码，特别是释放资源的代码
- 检查配置，特别是处理请求的线程配置

# 四、UDP 和 TCP 的区别

## UDP 报文结构

![image-20210819025217451](https://z3.ax1x.com/2021/08/19/f7cQHI.png)

## UDP 的特点

- 面向非连接。传输数据时，源端和终端不建立连接，发送简单的抓取应用程序数据，并尽可能快的发到网络中；接收端收到数据后将数据放到队列中，应用程序每次从队列中读取一个消息段。
- 不维护连接状态，支持同时向多个客户端传输相同的消息
- 数据包报头只有 8 个字节，额外开销较小
- 吞吐量只受限于数据生成速率、传输速率以及机器性能
- 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表
- 面向报文，不对应用程序提交的报文信息进行拆分或者合并，因此应用程序需要选择合适的报文大小

## UDP 和 TCP 的区别

 TCP 和 UDP 是 OSI 模型中传输层的协议，TCP 提供可靠的通信传输，而 UDP 则常被用于让网络和细节控制交给应用层的通信传输，两者的区别如下：

- **面向连接 vs 无连接**：TCP 有三次握手的连接过程；UDP 适合消息的多播发布。
- **可靠性**：TCP 利用握手、确认和重传机制保证可靠性；UDP可能丢失报文。
- **有序性**：TCP 利用序列号保证了报文的顺序性；而 UDP 不具备有序性
- **速度**：TCP 要创建连接，保证数据可靠性和有序性等，较慢；UDP 没有这些操作，更适合队速度敏感的应用。
- **量级**：TCP 属于重量级的，UDP 属于轻量级的，体现的元数据的头大小，TCP 是 20 个字节，UDP 是 8 个字节。

# 五、TCP 滑动窗口

RTT 和 RTO

- RTT ：一个数据包到收到应的 ACK，所花费的时间
- RTO ：重传时间间隔

TCP 使用滑动窗口做流量控制与乱序重排

- 保证 TCP 的可靠性
- 保证 TCP 的流控特性