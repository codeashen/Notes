(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{392:function(a,v,_){"use strict";_.r(v);var t=_(4),s=Object(t.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"一、持久化的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、持久化的作用"}},[a._v("#")]),a._v(" 一、持久化的作用")]),a._v(" "),v("p",[a._v("redis 所有数据保持在内存中，对数据的更新将异步地保存到磁盘上。")]),a._v(" "),v("p",[a._v("主流数据库的持久化方式：")]),a._v(" "),v("table",[v("thead",[v("tr",[v("th",[a._v("持久化方式")]),a._v(" "),v("th",[a._v("说明")]),a._v(" "),v("th",[a._v("数据库")])])]),a._v(" "),v("tbody",[v("tr",[v("td",[a._v("快照")]),a._v(" "),v("td",[a._v("数据库某时刻的完整备份")]),a._v(" "),v("td",[a._v("MySQL Dump"),v("br"),a._v("Redis RDB")])]),a._v(" "),v("tr",[v("td",[a._v("写日志")]),a._v(" "),v("td",[a._v("将数据库的变化操作记录在日志中，可以重放日志中的操作恢复数据")]),a._v(" "),v("td",[a._v("MySQL Binlog"),v("br"),a._v("Hbase HLog"),v("br"),a._v("Redis AOF")])])])]),a._v(" "),v("p",[a._v("Redis 持久化有 RDB 和 AOF 两种策略")]),a._v(" "),v("h1",{attrs:{id:"二、rdb"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、rdb"}},[a._v("#")]),a._v(" 二、RDB")]),a._v(" "),v("h2",{attrs:{id:"_2-1-rdb-介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-rdb-介绍"}},[a._v("#")]),a._v(" 2.1 RDB 介绍")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/03/23al1f.png",alt:"image-20210603174625696"}})]),a._v(" "),v("ul",[v("li",[a._v("Redis 在某一时刻记录此时内存中完整数据的一个快照，保存在 RDB 文件中")]),a._v(" "),v("li",[a._v("在启动重新载入 RDB 文件，就可以恢复数据到内存中")]),a._v(" "),v("li",[a._v("RDB 文件也是主从复制的一个媒介")])]),a._v(" "),v("h2",{attrs:{id:"_2-2-rdb-触发的三种方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-rdb-触发的三种方式"}},[a._v("#")]),a._v(" 2.2 RDB 触发的三种方式")]),a._v(" "),v("h3",{attrs:{id:"save-同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#save-同步"}},[a._v("#")]),a._v(" save（同步）")]),a._v(" "),v("p",[a._v("redis 客户端发送 "),v("code",[a._v("save")]),a._v(" 命令，服务端就会执行 rdb 操作。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/03/23BMVg.png",alt:"image-20210603180124647"}})]),a._v(" "),v("p",[v("code",[a._v("save")]),a._v(" 命令是一个同步命令，会等带服务端操作完成返回，在此之前服务端不能响应客户端的其他命令。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/03/23DPyV.png",alt:"image-20210603180525847"}})]),a._v(" "),v("p",[v("code",[a._v("save")]),a._v(" 命令的文件策略：如果有老的 rdb 文件，"),v("code",[a._v("save")]),a._v(" 命令会生成一个临时 rdb 文件（此时有两个 rdb 文件），然后覆盖掉老的 rdb 文件。")]),a._v(" "),v("p",[a._v("时间复杂度：O(n)")]),a._v(" "),v("h3",{attrs:{id:"bgsave-异步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bgsave-异步"}},[a._v("#")]),a._v(" bgsave（异步）")]),a._v(" "),v("p",[a._v("redis 客户端发送 "),v("code",[a._v("bgsave")]),a._v(' 命令，服务端收到命令后直接返回 "Background saving started"。然后在 redis 服务端中，会 fork 出一个子进程，在子进程中执行 rdb 操作，操作完成后告知主进程成功。')]),a._v(" "),v("p",[v("code",[a._v("bgsave")]),a._v(" 是异步的，所以执行 "),v("code",[a._v("bgsave")]),a._v(" 操作时服务端可以正常响应客户端的其他命令。"),v("code",[a._v("bgsave")]),a._v(" 的文件策略和时间复杂度同 "),v("code",[a._v("save")]),a._v("。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/03/23DYYd.png",alt:"image-20210603180735447"}})]),a._v(" "),v("p",[v("code",[a._v("save")]),a._v(" 和 "),v("code",[a._v("bgsave")]),a._v(" 对比：")]),a._v(" "),v("table",[v("thead",[v("tr",[v("th",[a._v("命令")]),a._v(" "),v("th",[a._v("save")]),a._v(" "),v("th",[a._v("bgsave")])])]),a._v(" "),v("tbody",[v("tr",[v("td",[a._v("IO 类型")]),a._v(" "),v("td",[a._v("同步")]),a._v(" "),v("td",[a._v("异步")])]),a._v(" "),v("tr",[v("td",[a._v("阻塞?")]),a._v(" "),v("td",[a._v("是")]),a._v(" "),v("td",[a._v("是（阻塞发生在 fork）")])]),a._v(" "),v("tr",[v("td",[a._v("复杂度")]),a._v(" "),v("td",[a._v("O(n)")]),a._v(" "),v("td",[a._v("o(n)")])]),a._v(" "),v("tr",[v("td",[a._v("优点")]),a._v(" "),v("td",[a._v("不会消耗额外内存")]),a._v(" "),v("td",[a._v("不阻塞客户端命令")])]),a._v(" "),v("tr",[v("td",[a._v("缺点")]),a._v(" "),v("td",[a._v("阻塞客户端命令")]),a._v(" "),v("td",[a._v("需要 fork，消耗内存")])])])]),a._v(" "),v("h3",{attrs:{id:"自动"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自动"}},[a._v("#")]),a._v(" 自动")]),a._v(" "),v("p",[a._v("不需要客户端操作，根据配置自动执行 rdb 操作。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/03/23sxFe.png",alt:"image-20210603182632417"}})]),a._v(" "),v("p",[a._v("rdb相关配置")]),a._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("# 自动rdb配置\nsave 900 1      # 每 900 秒有 1 个 key 改变\nsave 300 10     # 每 300 秒有 10 个 key 改变\nsave 60 10000   # 每 60 秒有 10000 个 key 改变\n\ndbfilename dump.rdb               # 指定 rbd 文件的名称\ndir ./                            # 工作目录，rdb、aof、日志文件 存在此目录\nstop-writes-on-bgsave-error yes   # 如果 bgsave 发生错误是否停止写入\nrdbcompression yes                # rdb 文件是否采用压缩的格式\nrdbchecksum yes                   # 是否对 rdb 文件进行校验和检验\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br"),v("span",{staticClass:"line-number"},[a._v("2")]),v("br"),v("span",{staticClass:"line-number"},[a._v("3")]),v("br"),v("span",{staticClass:"line-number"},[a._v("4")]),v("br"),v("span",{staticClass:"line-number"},[a._v("5")]),v("br"),v("span",{staticClass:"line-number"},[a._v("6")]),v("br"),v("span",{staticClass:"line-number"},[a._v("7")]),v("br"),v("span",{staticClass:"line-number"},[a._v("8")]),v("br"),v("span",{staticClass:"line-number"},[a._v("9")]),v("br"),v("span",{staticClass:"line-number"},[a._v("10")]),v("br")])]),v("p",[a._v("rdb 配置最佳实践")]),a._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("#### 不开启自动保存 ####\n\n# 由于 redis 单线程，通常一台机器上启动好几个 redis 实例，可以根据端口号区分 rdb 文件属于哪个实例\ndbfilename dump-${port}.rdb\n\n# 自定义工作目录\ndir /bigdiskpath\n\nstop-writes-on-bgsave-error yes\nrdbcompression yes\nrdbchecksum yes\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br"),v("span",{staticClass:"line-number"},[a._v("2")]),v("br"),v("span",{staticClass:"line-number"},[a._v("3")]),v("br"),v("span",{staticClass:"line-number"},[a._v("4")]),v("br"),v("span",{staticClass:"line-number"},[a._v("5")]),v("br"),v("span",{staticClass:"line-number"},[a._v("6")]),v("br"),v("span",{staticClass:"line-number"},[a._v("7")]),v("br"),v("span",{staticClass:"line-number"},[a._v("8")]),v("br"),v("span",{staticClass:"line-number"},[a._v("9")]),v("br"),v("span",{staticClass:"line-number"},[a._v("10")]),v("br"),v("span",{staticClass:"line-number"},[a._v("11")]),v("br")])]),v("h2",{attrs:{id:"_2-3-rdb-触发机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-rdb-触发机制"}},[a._v("#")]),a._v(" 2.3 rdb 触发机制")]),a._v(" "),v("ul",[v("li",[a._v("全量复制：主从复制的时候会生成 rdb 文件")]),a._v(" "),v("li",[a._v("debug reload：redis 提供 debug 级别的重启，会生成 rdb 文件")]),a._v(" "),v("li",[a._v("shutdown：执行 "),v("code",[a._v("shutdown save")]),a._v(" 会生成 rdb 文件")])]),a._v(" "),v("h1",{attrs:{id:"三、aof"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、aof"}},[a._v("#")]),a._v(" 三、AOF")]),a._v(" "),v("h2",{attrs:{id:"_3-1-aof-介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-aof-介绍"}},[a._v("#")]),a._v(" 3.1 AOF 介绍")]),a._v(" "),v("p",[a._v("RDB 持久化的问题：")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("耗时耗性能：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/04/2GXHXR.png",alt:"image-20210604145455351"}})])]),a._v(" "),v("li",[v("p",[a._v("不可控，丢失数据：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/04/2GjwuR.png",alt:"image-20210604145708231"}})])])]),a._v(" "),v("p",[a._v("为了解决上述问题RDB的问题，redis 还提供了 AOF 持久化方式。如下图所示，redis 写命令都会追加到 aof 文件中，重启 redis 后加载 aof 文件，恢复数据。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/04/2GvAM9.png",alt:"image-20210604150016150"}})]),a._v(" "),v("h2",{attrs:{id:"_3-2-aof-的三种策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-aof-的三种策略"}},[a._v("#")]),a._v(" 3.2 AOF 的三种策略")]),a._v(" "),v("ul",[v("li",[a._v("always：每一条命令都刷到 aof 文件中")]),a._v(" "),v("li",[a._v("everysec（默认）：每秒把缓冲区中的命令刷到 aof 文件中")]),a._v(" "),v("li",[a._v("no：由操作系统决定何时将缓冲区中命令刷到 aof 文件中")])]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/04/2JS7es.png",alt:"image-20210604151348099"}})]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/04/2JpUmj.png",alt:"image-20210604151506860"}})]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/04/2Jpx4P.png",alt:"image-20210604151642397"}})]),a._v(" "),v("p",[a._v("三种策略对比：")]),a._v(" "),v("table",[v("thead",[v("tr",[v("th",[a._v("命令")]),a._v(" "),v("th",[a._v("优点")]),a._v(" "),v("th",[a._v("缺点")])])]),a._v(" "),v("tbody",[v("tr",[v("td",[a._v("always")]),a._v(" "),v("td",[a._v("不丢失数据")]),a._v(" "),v("td",[a._v("IO 开销较大，一般的 sata 盘只有几百 TPS")])]),a._v(" "),v("tr",[v("td",[a._v("everysec")]),a._v(" "),v("td",[a._v("每秒一次 fsync 丢 1 秒数据")]),a._v(" "),v("td",[a._v("丢 1 秒数据")])]),a._v(" "),v("tr",[v("td",[a._v("no")]),a._v(" "),v("td",[a._v("不用管")]),a._v(" "),v("td",[a._v("不可控")])])])]),a._v(" "),v("h2",{attrs:{id:"_3-3-aof-重写"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-aof-重写"}},[a._v("#")]),a._v(" 3.3 AOF 重写")]),a._v(" "),v("h3",{attrs:{id:"aof-重写介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写介绍"}},[a._v("#")]),a._v(" AOF 重写介绍")]),a._v(" "),v("p",[a._v("aof 文件记录 redis 的写入命令，随着写入命令越来越多，aof 文件将越来越大。为了解决这个问题，redis 提供了 aof 重写机制。")]),a._v(" "),v("p",[a._v("aof 重写会将写入命令中重复的、无效的、过时的等命令进行优化，使生成的 aof 文件很小。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/04/2JnvLt.png",alt:"image-20210604155011373"}})]),a._v(" "),v("h3",{attrs:{id:"aof-重写的优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写的优点"}},[a._v("#")]),a._v(" aof 重写的优点")]),a._v(" "),v("ul",[v("li",[a._v("减少硬盘占用量")]),a._v(" "),v("li",[a._v("加速恢复速度")])]),a._v(" "),v("h3",{attrs:{id:"aof-重写实现的两种方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写实现的两种方式"}},[a._v("#")]),a._v(" aof 重写实现的两种方式")]),a._v(" "),v("ol",[v("li",[v("code",[a._v("bgrewriteaof")]),a._v(" 命令：类似于 bgsave ，fork 出子进程异步进行 aof 重写")]),a._v(" "),v("li",[a._v("AOF 重写配置")])]),a._v(" "),v("p",[v("strong",[a._v("bgrewriteaof 命令")])]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/04/2JMrZt.png",alt:"image-20210604160539972"}})]),a._v(" "),v("p",[v("strong",[a._v("AOF 重写配置")])]),a._v(" "),v("table",[v("thead",[v("tr",[v("th",[a._v("配置名")]),a._v(" "),v("th",[a._v("含义")])])]),a._v(" "),v("tbody",[v("tr",[v("td",[a._v("auto-aof-rewrite-min-size")]),a._v(" "),v("td",[a._v("AOF 文件重写需要的尺寸（即当 AOF 文件超过多大时开始重写）")])]),a._v(" "),v("tr",[v("td",[a._v("auto-aof-rewrite-percentage")]),a._v(" "),v("td",[a._v("AOF 文件增长率（比如配置 100，这次 200M 重写了，下次就是 400M 重写）")])])])]),a._v(" "),v("p",[a._v("redis 中还有两个统计数据")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("aof_current_size")]),a._v("：AOF 当前尺寸（单位：字节）")]),a._v(" "),v("li",[v("code",[a._v("aof_base_size")]),a._v("：AOF 上次启动和重写的尺寸（单位：字节）")])]),a._v(" "),v("p",[a._v("当同时满足以下条件时，自动触发 aof 重写")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("aof_current_size > auto-aof-rewrite-min-size")])]),a._v(" "),v("li",[v("code",[a._v("(aof_current_size - aof_base_size) / aof_base_size > auto-aof-rewrite-percentage")])])]),a._v(" "),v("p",[a._v("AOF 重写流程：")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/04/2J351U.png",alt:"image-20210604162310804"}})]),a._v(" "),v("ol",[v("li",[a._v("无论是执行 "),v("code",[a._v("bgrewriteaof")]),a._v(" 命令还是自动触发，AOF 重写最终本质都会执行 "),v("code",[a._v("bgrewriteaof")]),a._v(" 操作")]),a._v(" "),v("li",[a._v("主进程会 fork 出一个子进程，来执行 aof 操作")]),a._v(" "),v("li",[v("code",[a._v("aof_buf")]),a._v(" 记录了现有的内存数据，将这些数据更新到旧的 aof 文件中（内存回溯）")]),a._v(" "),v("li",[v("code",[a._v("aof_rewrite_buf")]),a._v(" 记录了重写期间的写命令，会记录在一个新的aof文件中，最后合并到旧aof文件中")])]),a._v(" "),v("p",[a._v("推荐参考："),v("a",{attrs:{href:"https://blog.csdn.net/hezhiqiang1314/article/details/69396887",target:"_blank",rel:"noopener noreferrer"}},[a._v("Redis 之 AOF 重写及其实现原理"),v("OutboundLink")],1)]),a._v(" "),v("h2",{attrs:{id:"_3-4-aof相关配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-aof相关配置"}},[a._v("#")]),a._v(" 3.4 AOF相关配置")]),a._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v('appendonly yes                           #是否开启aof\nappendfilename "appendonly-${port}.aof"  #aof文件名\nappendfsync everysec                     #aof刷盘策略\ndir/bigdiskpath                          #工作目录\nno-appendfsync-on-rewrite yes            #aof重写的时候不记录aof命令（是否可以容忍重写期间丢数据）\nauto-aof-rewrite-percentage 100          #aof重写增长率\nauto-aof-rewrite-min-size 64mb           #aof重写尺寸\naof-load-truncated yes                   #是否加载被截断的aof文件（例如刷入aof文件途中宕机了）\n')])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br"),v("span",{staticClass:"line-number"},[a._v("2")]),v("br"),v("span",{staticClass:"line-number"},[a._v("3")]),v("br"),v("span",{staticClass:"line-number"},[a._v("4")]),v("br"),v("span",{staticClass:"line-number"},[a._v("5")]),v("br"),v("span",{staticClass:"line-number"},[a._v("6")]),v("br"),v("span",{staticClass:"line-number"},[a._v("7")]),v("br"),v("span",{staticClass:"line-number"},[a._v("8")]),v("br")])]),v("h1",{attrs:{id:"四、rdb-和-aof-选择"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、rdb-和-aof-选择"}},[a._v("#")]),a._v(" 四、RDB 和 AOF 选择")]),a._v(" "),v("p",[v("strong",[a._v("RDB 和 AOF 对比")])]),a._v(" "),v("table",[v("thead",[v("tr",[v("th",[a._v("命令")]),a._v(" "),v("th",[a._v("RDB")]),a._v(" "),v("th",[a._v("AOF")])])]),a._v(" "),v("tbody",[v("tr",[v("td",[a._v("启动优先级")]),a._v(" "),v("td",[a._v("低")]),a._v(" "),v("td",[a._v("高")])]),a._v(" "),v("tr",[v("td",[a._v("体积")]),a._v(" "),v("td",[a._v("小")]),a._v(" "),v("td",[a._v("大")])]),a._v(" "),v("tr",[v("td",[a._v("恢复速度")]),a._v(" "),v("td",[a._v("快")]),a._v(" "),v("td",[a._v("慢")])]),a._v(" "),v("tr",[v("td",[a._v("数据安全性")]),a._v(" "),v("td",[a._v("丢数据")]),a._v(" "),v("td",[a._v("根据策略决定")])]),a._v(" "),v("tr",[v("td",[a._v("轻重")]),a._v(" "),v("td",[a._v("重")]),a._v(" "),v("td",[a._v("轻")])])])]),a._v(" "),v("p",[v("strong",[a._v("RDB 最佳策略")])]),a._v(" "),v("ul",[v("li",[a._v("“关”")]),a._v(" "),v("li",[a._v("集中管理")]),a._v(" "),v("li",[a._v("主从，从开？")])]),a._v(" "),v("p",[v("strong",[a._v("AOF 最佳策略")])]),a._v(" "),v("ul",[v("li",[a._v("“开”：缓存和存储")]),a._v(" "),v("li",[a._v("AOF重写集中管理")]),a._v(" "),v("li",[a._v("everysec")])]),a._v(" "),v("p",[v("strong",[a._v("最佳策略")])]),a._v(" "),v("ul",[v("li",[a._v("小分片")]),a._v(" "),v("li",[a._v("缓存或者存储")]),a._v(" "),v("li",[a._v("监控（硬盘、内存、负载、网络）")]),a._v(" "),v("li",[a._v("足够的内存")])]),a._v(" "),v("h1",{attrs:{id:"五、持久化开发运维问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、持久化开发运维问题"}},[a._v("#")]),a._v(" 五、持久化开发运维问题")]),a._v(" "),v("h2",{attrs:{id:"_5-1-fork-操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-fork-操作"}},[a._v("#")]),a._v(" 5.1 fork 操作")]),a._v(" "),v("ul",[v("li",[a._v("同步操作：Fork 操作只是做内存页的拷贝，而不是做整个内存的拷贝，所以说，大部分情况下速度是非常快的，但是如果本身的 fork 操作比较慢，或者是卡在了某个地方，那么它就会阻塞 redis 的主线程。")]),a._v(" "),v("li",[a._v("与内存量息息相关：内存越大，耗时越长（与机器类型有关）")]),a._v(" "),v("li",[v("code",[a._v("info:latest fork usec")]),a._v("：该参数用来查上一次持久化的执行时间，用来辅助对持久化文件内存相关信息进行监控")])]),a._v(" "),v("p",[a._v("改善 fork：")]),a._v(" "),v("ul",[v("li",[a._v("优先使用物理机或者高效支持 fork 操作的虚拟化技术")]),a._v(" "),v("li",[a._v("控制 Redis 实例最大可用内存：maxmemory")]),a._v(" "),v("li",[a._v("合理配置 Linux 内存分配策略：vm.overcommit_memory=1")]),a._v(" "),v("li",[a._v("降低 fork 频率：例如放宽 AOF 重写自动触发时机，不必要的全量复制")])]),a._v(" "),v("h2",{attrs:{id:"_5-2-子进程开销和优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-子进程开销和优化"}},[a._v("#")]),a._v(" 5.2 子进程开销和优化")]),a._v(" "),v("ol",[v("li",[a._v("CPU\n"),v("ul",[v("li",[a._v("开销：RDB 和 AOF 文件生成，属于 CPU 密集型")]),a._v(" "),v("li",[a._v("优化：不做 CPU 绑定，不和 CPU 密集型部署")])])]),a._v(" "),v("li",[a._v("内存\n"),v("ul",[v("li",[a._v("开销：fork 内存开销，copy-on-write。")]),a._v(" "),v("li",[a._v("优化："),v("code",[a._v("echo never > /sys/kernel/mm/transparent_hugepage/enabled")])])])]),a._v(" "),v("li",[a._v("硬盘\n"),v("ul",[v("li",[a._v("开销：AOF 和 RDB 文件写入，可以结合 iostat、iotop 分析")]),a._v(" "),v("li",[a._v("优化：\n"),v("ul",[v("li",[a._v("不要和高硬盘负载服务部署一起 ： 存储服务、消息队列等")]),a._v(" "),v("li",[v("code",[a._v("no-appendfsync-on-rewrite = yes")])]),a._v(" "),v("li",[a._v("根据写入量决定磁盘类型：例如 ssd")]),a._v(" "),v("li",[a._v("单机多实例持久化文件目录可以考虑分盘")])])])])])]),a._v(" "),v("h2",{attrs:{id:"_5-3-aof-追加阻塞"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-aof-追加阻塞"}},[a._v("#")]),a._v(" 5.3 AOF 追加阻塞")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/04/2J4KsS.png",alt:"image-20210604171702424"}})]),a._v(" "),v("p",[a._v("如果我们使用 AOF 进行持久化，那么一般会使用每秒刷盘的策略。主线程将数据加载到缓冲区，同时它还有一个 AOF 同步线程，去负责每秒同步刷盘操作。主线程还会负责一项工作，主线程会对比上次 AOF 同步的时间，如果上次同步时间在 2 秒之内，主线程就会返回；如果距离上次同步时间超过了 2 秒，主线程会阻塞，直到同步完成。实际上，这也是为了达到保证 AOF 同步安全的一种策略，所以为了达到这一目的，它会一直阻塞直到达到同步完成。")]),a._v(" "),v("p",[a._v("但是，这里会产生两个问题：")]),a._v(" "),v("ol",[v("li",[a._v("主线程是不能阻塞的，因为主线程要负责日常命令的处理，是非常宝贵的资源")]),a._v(" "),v("li",[a._v("每秒刷盘的策略可能不只会丢失 1 秒，而是可能会丢失 2 秒的数据")])]),a._v(" "),v("p",[v("strong",[a._v("AOF 阻塞定位")])]),a._v(" "),v("p",[a._v("定位 AOF 阻塞有两重方式，查看 redis 日志和执行 "),v("code",[a._v("info Persistence")]),a._v(" 命令。")]),a._v(" "),v("p",[a._v("方式一：redis 日志")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/04/2J5ckj.png",alt:"image-20210604172244123"}})]),a._v(" "),v("p",[a._v("在 redis 日志中，有这么一段，它会告诉你，你的异步 AOF 同步可能花了太长时间了，你的磁盘是不是有问题，而且这个过程有可能拖慢你的 redis。")]),a._v(" "),v("p",[a._v("方式二：命令")]),a._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("> info Persistence\n")])]),a._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[a._v("1")]),v("br")])]),v("p",[v("img",{attrs:{src:"https://z3.ax1x.com/2021/06/04/2J5vjK.png",alt:"image-20210604172353667"}})])])}),[],!1,null,null,null);v.default=s.exports}}]);