# 在节点间穿针引线（反转链表）

## 题目分析

> [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
>
> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

通常情况下链表问题我们是不能操作节点中值的，应该操作节点的指向，即实现如下图操作。

![image-20210830223959459](https://z3.ax1x.com/2021/08/30/hND6s0.png)

在遍历链表时，将当前节点的 `next` 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。整体过程如下图。

![image-20210830224917942](https://z3.ax1x.com/2021/08/30/hNsM3d.png)

## 代码实现

1. 迭代法

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode() {}
    *     ListNode(int val) { this.val = val; }
    *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    * }
    * 迭代法
    * 时间复杂度: O(n)
    * 空间复杂度: O(1)
    */
   class Solution {
       public ListNode reverseList(ListNode head) {
           ListNode cur = head;   // 保存当前遍历的节点
           ListNode pre = null;   // 保存前一个节点
           while (cur != null) {
               ListNode next = cur.next;  // 暂存下一个节点
               cur.next = pre;  // 指针反转
               // 操作完成，pre 和 cur 后移动一位，继续
               pre = cur;
               cur = next;
           }
   
           return pre;
       }
   }
   ```

2. 递归法

   ```java
   // todo
   ```

## 相关问题

> [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
>
> 给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 right 的链表节点，返回 **反转后的链表** 。



> [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)
>
> 存在一个按升序排列的链表，给你这个链表的头节点 `head` ，请你删除所有重复的元素，使每个元素 **只出现一次** 。返回同样按升序排列的结果链表。



> [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)
>
> 给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。你应当 **保留** 两个分区中每个节点的初始相对位置。



> [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)
>
> 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。
>
> 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。



> [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)
>
> 给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。
>
> 请你将两个数相加，并以相同形式返回一个表示和的链表。
>
> 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。



> [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)
>
> 给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
>
> 你可以假设除了数字 0 之外，这两个数字都不会以零开头。
>

# 设立链表的虚拟头结点（移除链表元素）

## 题目分析

> [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)
>
> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

要删除一个元素应该怎么做呢？我们在遍历链表过程中，如果发现当前节点 cur 的下一个节点就是待删除的节点 delNode，我们就执行 `cur.next = delNode.next` 就可以直接跳过待删除节点（可选操作：释放 delNode 空间），如下图所示。

![image-20210830230902920](https://z3.ax1x.com/2021/08/30/hN2plQ.png)

这个操作对 delNode 是最后一个元素同样适用。但是这样的操作对 delNode 是第一个元素是不适用的，因为这套操作的 cur 是 delNode 的前一个节点，如果 `delNode == head`，则 delNode 的前面没有任何元素。对此，我们需要对头节点进行单独操作。

## 代码实现

1. 迭代法，不设置虚拟头节点。

   ```java
   /** 
    * 迭代法
    * 时间复杂度: O(n)
    * 空间复杂度: O(1)
    */
   class Solution {
       public ListNode removeElements(ListNode head, int val) {
           // 删除链表开头所有符合条件的节点
           while (head != null && head.val == val)
               head = head.next;
   
           if (head == null) return head;
   
           // 开始逐个考察节点，删除中间的节点
           ListNode cur = head;
           while (cur.next != null) {
               if (cur.next.val == val) {
                   cur.next = cur.next.next;  // 跨过待删除节点
               } else {
                   cur = cur.next;
               }
           }
   
           return head;
       }
   }
   ```

2. 迭代法，设置虚拟头节点。

   ```java
   /** 
    * 迭代法,设置虚拟头节点
    * 时间复杂度: O(n)
    * 空间复杂度: O(1)
    */
   class Solution {
       public ListNode removeElements(ListNode head, int val) {
           // 设置虚拟头节点
           ListNode dummyHead = new ListNode(0);
           dummyHead.next = head;
   
           // 开始逐个考察节点，删除中间的节点
           ListNode cur = dummyHead;
           while (cur.next != null) {
               if (cur.next.val == val) {
                   cur.next = cur.next.next;  // 跨过待删除节点
               } else {
                   cur = cur.next;
               }
           }
   
           return dummyHead.next;
       }
   }
   ```
   
3. 递归法

   ```java
   // todo
   ```


## 相关问题

> [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)
>
> 存在一个按升序排列的链表，给你这个链表的头节点 `head` ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 **没有重复出现** 的数字。
>
> 返回同样按升序排列的结果链表。
>



> [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
>
> 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 



# 复杂的穿针引线（两两交换链表中的节点）

## 问题分析

> [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)
>
> 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。
>
> ```
> 输入：head = [1,2,3,4]
> 输出：[2,1,4,3]
> ```





## 相关问题

> [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)
>
> 给你一个链表，每 *k* 个节点一组进行翻转，请你返回翻转后的链表。
>
> *k* 是一个正整数，它的值小于或等于链表的长度。
>
> 如果节点总数不是 *k* 的整数倍，那么请将最后剩余的节点保持原有顺序。
>



> [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)
>
> 对链表进行插入排序。
>
> 插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
> 每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。



> [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)
>
> 给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。



# 不仅仅是穿针引线 Delete Node in a Linked List

# 链表与双指针 Remove Nth Node Form End of List

