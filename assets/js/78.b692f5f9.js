(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{404:function(t,_,a){"use strict";a.r(_);var v=a(4),s=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"一、search-两个阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、search-两个阶段"}},[t._v("#")]),t._v(" 一、Search 两个阶段")]),t._v(" "),_("p",[t._v("Search 执行的时候实际分两个步骤运作的，即 "),_("code",[t._v("Query-Then-Fetch")])]),t._v(" "),_("ul",[_("li",[t._v("Query 阶段：查询出文档id")]),t._v(" "),_("li",[t._v("Fetch 阶段：拉取文档数据")])]),t._v(" "),_("p",[_("strong",[t._v("Query 阶段过程：")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rqn7M4.png",alt:"image-20201227032936521"}})]),t._v(" "),_("blockquote",[_("p",[t._v("注意：上述步骤中选取的 3 个分片，必须包含索引的完整数据，即 0, 1, 2 分片必须都有，但是可以是主分片也可以是副本分片")])]),t._v(" "),_("p",[_("strong",[t._v("Fetch 阶段过程：")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rqnbL9.png",alt:"image-20201227033057665"}})]),t._v(" "),_("h1",{attrs:{id:"二、相关性算分问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、相关性算分问题"}},[t._v("#")]),t._v(" 二、相关性算分问题")]),t._v(" "),_("p",[t._v("相关性算分在 shard 与 shard 间是相互独立的，也就意味着同一个 Term 的 IDF 等值在不同 shard 上是不同的。文档的相关性算分和它所处的 shard 相关。")]),t._v(" "),_("p",[t._v("在文档数量不多时，会导致相关性算分严重不准的情况发生。")]),t._v(" "),_("p",[t._v("解决思路有两个：")]),t._v(" "),_("ol",[_("li",[t._v("设置分片数为 1 个，从根本上排除问题，在文档数量不多的时候可以考虑该方案，比如百万到干万级别的文档数量")]),t._v(" "),_("li",[t._v("使用 "),_("code",[t._v("DFS Query-then-Fetch")]),t._v(" 查询方式")])]),t._v(" "),_("p",[_("code",[t._v("DFS Query-then-Fetch")]),t._v(" 是在拿到所有文档后再重新完整的计算一次相关性算分，耗费更多的 cpu 和内存，执行性能也比较低下，一般不建议使用。使用方式如下：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rqnLZR.png",alt:"image-20201227033703844"}})]),t._v(" "),_("h1",{attrs:{id:"三、排序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、排序"}},[t._v("#")]),t._v(" 三、排序")]),t._v(" "),_("h2",{attrs:{id:"_3-1-es-排序操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-es-排序操作"}},[t._v("#")]),t._v(" 3.1 ES 排序操作")]),t._v(" "),_("p",[t._v("es 默认会采用相关性算分排序，用户可以通过设定 sorting 参数来自行设定排序规则")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rqnOd1.png",alt:"image-20201227033849683"}})]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rqnXIx.png",alt:"image-20201227033954663"}})]),t._v(" "),_("p",[t._v("按照字符串排序比较特殊，因为 es 有 "),_("code",[t._v("text")]),t._v(" 和 "),_("code",[t._v("keyword")]),t._v(" 两种类型。如果针对 text 类型排序，如下所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rqnvi6.png",alt:"image-20201227034328731"}})]),t._v(" "),_("p",[t._v("针对 keyword 类型排序，可以返回预期结果：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rqnxJK.png",alt:"image-20201227034408381"}})]),t._v(" "),_("h2",{attrs:{id:"_3-2-fielddata-和-docvalues"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-fielddata-和-docvalues"}},[t._v("#")]),t._v(" 3.2 FieldData 和 DocValues")]),t._v(" "),_("p",[t._v("排序的过程实质是对字段原始内容排序的过程，这个过程中 "),_("strong",[t._v("倒排索引无法发挥作用")]),t._v("，需要用到 "),_("strong",[t._v("正排索引")]),t._v("，也就是通过文档 id 和字段可以快速得到字段原始内容，然后按照原始内容进行排序。")]),t._v(" "),_("p",[t._v("es 对此提供了 2 种实现方式：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("fielddata")]),t._v("，默认禁用")]),t._v(" "),_("li",[_("code",[t._v("doc values")]),t._v("，默认启用，除了text类型")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rqnzRO.png",alt:"image-20201227034644517"}})]),t._v(" "),_("h3",{attrs:{id:"_3-2-1-fielddata"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-fielddata"}},[t._v("#")]),t._v(" 3.2.1 Fielddata")]),t._v(" "),_("p",[t._v("Fielddata 默认是关闭的，可以通过如下 api 开启：")]),t._v(" "),_("ul",[_("li",[t._v("此时字符串是按照分词后的 term 排序，往往结果很难符合预期")]),t._v(" "),_("li",[t._v("一般是在对分词做聚合分析的时候开启")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rquSzD.png",alt:"image-20201227034851533"}})]),t._v(" "),_("h3",{attrs:{id:"_3-2-2-doc-values"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-doc-values"}},[t._v("#")]),t._v(" 3.2.2 Doc Values")]),t._v(" "),_("p",[t._v("Doc Values 默认是启用的，可以在创建索引的时候关闭，如果后面要再开启 doc values，需要做 reindex 操作。如果明确知道不会按照某个字段进行排序，可以考虑关闭 doc values，最大限度的加快索引速度，减少磁盘占用。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rquCsH.png",alt:"image-20201227035133503"}})]),t._v(" "),_("h3",{attrs:{id:"_3-2-3-docvalue-fields-获取存储内容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3-docvalue-fields-获取存储内容"}},[t._v("#")]),t._v(" 3.2.3 docvalue_fields 获取存储内容")]),t._v(" "),_("p",[t._v("可以通过该字段获取 "),_("code",[t._v("fielddata")]),t._v(" 或者 "),_("code",[t._v("doc values")]),t._v(" 中存储的内容")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rqukdI.png",alt:"image-20201227035344484"}})]),t._v(" "),_("h1",{attrs:{id:"四、分页与遍历"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、分页与遍历"}},[t._v("#")]),t._v(" 四、分页与遍历")]),t._v(" "),_("p",[t._v("es 提供了 3 种方式来解决分页与遍历的问题：")]),t._v(" "),_("ul",[_("li",[t._v("from/size")]),t._v(" "),_("li",[t._v("scroll")]),t._v(" "),_("li",[t._v("search_after")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("类型")]),t._v(" "),_("th",[t._v("场景")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("From/Size")]),t._v(" "),_("td",[t._v("需要实时获取顶部的部分文档，且需要自由翻页")])]),t._v(" "),_("tr",[_("td",[t._v("Scroll")]),t._v(" "),_("td",[t._v("需要全部文档，如导出所有数据的功能")])]),t._v(" "),_("tr",[_("td",[t._v("Search_After")]),t._v(" "),_("td",[t._v("需要全部文档，不需要自由翻页")])])])]),t._v(" "),_("h2",{attrs:{id:"_4-1-from-size"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-from-size"}},[t._v("#")]),t._v(" 4.1 from/size")]),t._v(" "),_("p",[t._v("最常用的分页方案，from 指明开始位置，size 指明获取总数")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rquZJf.png",alt:"image-20201227040011543"}})]),t._v(" "),_("p",[_("strong",[t._v("深度分页问题")])]),t._v(" "),_("p",[t._v("深度分页是一个经典的问题：在数据分片存储的情况下如何获取前 1000 个文档？")]),t._v(" "),_("ul",[_("li",[t._v("获取从 990~1000 的文档时，会在每个分片上都先获取 1000 个文档，然后再由 Coordinating Node 聚合所有分片的结果后再排序选取前 1000 个文档")]),t._v(" "),_("li",[t._v("页数越深，处理文档越多，占用内存越多，耗时越长。尽量避免深度分页，es 通过 "),_("code",[t._v("index.max result window")]),t._v(" 限定最多到 10000 条数据")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rquKyQ.png",alt:"image-20201227040232980"}})]),t._v(" "),_("h2",{attrs:{id:"_4-2-scroll"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-scroll"}},[t._v("#")]),t._v(" 4.2 scroll")]),t._v(" "),_("p",[t._v("遍历文档集的 api，以快照的方式来避免深度分页的问题。")]),t._v(" "),_("ul",[_("li",[t._v("不能用来做实时搜索，因为数据不是实时的")]),t._v(" "),_("li",[t._v("尽量不要使用复杂的 sort 条件，使用 _doc 最高效")]),t._v(" "),_("li",[t._v("使用稍显复杂")])]),t._v(" "),_("p",[_("strong",[t._v("使用步骤：")])]),t._v(" "),_("ol",[_("li",[_("p",[t._v("第一步需要发起一个 "),_("code",[t._v("scroll search")]),t._v("，es 在收到该请求后会根据查询条件创建文档 id 合集的快照，并返回一个 "),_("code",[t._v("scroll id")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rqu3oq.png",alt:"image-20201227040800272"}})])]),t._v(" "),_("li",[_("p",[t._v("第二步使用 "),_("code",[t._v("scroll id")]),t._v(" 进行 "),_("code",[t._v("scorll")]),t._v(" 操作，获取数据集合和下一批次的 "),_("code",[t._v("scroll id")]),t._v("，不断迭代调用直到返回 "),_("code",[t._v("hits.hits")]),t._v(" 数组为空时停止。")]),t._v(" "),_("p",[t._v("这里每次调用都可以在此指定快照时间，用于刷新快照有效时间，防止失效。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rquGF0.png",alt:"image-20201227040918387"}})])])]),t._v(" "),_("p",[t._v("过多的 scroll 调用会占用大量内存，可以通过 clear api 删除过多的 scroll 快照：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rquJYV.png",alt:"image-20201227041039308"}})]),t._v(" "),_("h2",{attrs:{id:"_4-3-search-after"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-search-after"}},[t._v("#")]),t._v(" 4.3 search_after")]),t._v(" "),_("p",[t._v("search_after 也避免深度分页的性能问题，并提供实时的下一页文档获取功能。使用此功能搜索，必须指定排序值，并且排序值必须唯一。")]),t._v(" "),_("ul",[_("li",[t._v("缺点是不能使用from参数，即不能指定页数")]),t._v(" "),_("li",[t._v("只能下一页，不能上一页")]),t._v(" "),_("li",[t._v("使用简单")])]),t._v(" "),_("p",[t._v("使用步骤如下：")]),t._v(" "),_("ol",[_("li",[t._v("为正常的搜索，但要指定 sort 值，并保证值唯一")]),t._v(" "),_("li",[t._v("为使用上一步最后一个文档的 sort 值进行查询")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rquYWT.png",alt:"image-20201227041244726"}})]),t._v(" "),_("p",[t._v("search_after 是如何避免深度分页问题的？")]),t._v(" "),_("p",[t._v("通过唯一排序值定位将每次要处理的文档数都控制在 size 内。即指定了排序值之后，每个分片只需要返回排序值之后的 size 条数据即可，不需要返回前 n 条完整数据。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://s3.ax1x.com/2020/12/29/rquNSU.png",alt:"image-20201227041458696"}})])])}),[],!1,null,null,null);_.default=s.exports}}]);