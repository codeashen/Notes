# 树形问题（电话号码的字母组合）

上一章中，我们介绍了二叉树相关问题，通常需要使用递归算法，这一章我们来看一下更多递归的应用，以及使用递归算法时一个非常经典的思想——**回溯法**，这个思想通常都应用在一类问题上，我们称作树形问题。这类问题本身没有定义在二叉树机构中，但是当我们具体分析后，会发现解决这个问题的思路本质是一棵树的形状。

这一节我们先从一个比较简单的问题入手。

## 问题分析

> [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)
>
> 给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt="img" style="zoom: 33%;" />
>
> ```
> 输入：digits = "23" 
> 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
> ```

如下图所示，我们以 `digits = "23"` 为例，先来看 `2` 可以代表 `(a, b , c)` 三个字母，所以我们就需要基于 `(a, b , c)` 这三种可能来考虑下一个数字 `3` 能代表哪些字母，`3` 能代表 `(d, e, f)` 三个字母，所以我们就得到了 `3 * 3 = 9` 种字母组合 `["ad","ae","af","bd","be","bf","cd","ce","cf"]`。

![image-20210902153448426](https://z3.ax1x.com/2021/09/02/hrNo24.png)

经过分析，我们看到形成了一棵树，这类问题的思路是隐藏在一颗树种的，所以我们把这类问题称为树形问题。因为是树形结构，所以我们很容易想到使用递归的方式来解决，这个问题的递归结构在哪里呢？

我们从 `2` 开始看可以表示哪些字母，我们只需要求出 `3` 能代表哪些字母，然后在前面加上 `2` 所能代表的这些字母，一起就构成了结果。



```java
/**
 * 时间复杂度: O(3^m * 4^n)，m 为可以代表 3 个字母的数字个数，n 为可以代表 4 个字母的数字个数
 * 空间复杂度: O(m + n)，m+n 为输入数字的总个数
 */
class Solution {
    // 每个数字对应的字母，0 和 1 在本题中不用
    private String[] letterMap = {
        " ",    // 0
        "",     // 1
        "abc",  // 2
        "def",  // 3
        "ghi",  // 4
        "jkl",  // 5
        "mno",  // 6
        "pqrs", // 7
        "tuv",  // 8
        "wxyz"  // 9
    };

    // 存放结果
    private List<String> res;

    public List<String> letterCombinations(String digits) {
        res = new ArrayList<>();
        if (digits.equals(""))
            return res;
        findCombination(digits, 0, "");
        return res;
    }

    /**
     * 翻译 digits 字符串 index 索引下的字符，拼接到字符串 s 上，然后添加到结果 res 中
     *
     * @param digits 数字字符串
     * @param index  将要翻译的索引
     * @param str    到目前位置翻译的结果，当翻译到 digits 最后一位时将其添加到 res 中
     */
    private void findCombination(String digits, int index, String str) {
        if (index == digits.length()) {
            res.add(str);
            return;
        }

        String letters = letterMap[digits.charAt(index) - '0'];
        for (int i = 0; i < letters.length(); i++)
            findCombination(digits, index + 1, str + letters.charAt(i));
    }
}
```

# 什么是回溯

## 回溯法介绍

下面我们结合图示来解释上一节题目对应程序的运行过程。

![image-20210902153448426](https://z3.ax1x.com/2021/09/02/hrNo24.png)

`2` 可以表示  `(a, b, c)` 三个字母，我们先尝试 `2=a` 的时候来到 `3` 节点，对于 `3` 可以表示 `(d, e, f)`，当 `3` 表示 `d` 我们就得到了 `ad`， 然后回到 `3` 节点，它还可以表示 `e` 我们就得到了 `ae`，再回到 `3` 节点还可以表示 `f` 我们就得到了 `af`，此时 `3` 的所以可能已经尝试完了，我们再回到 `2` 节点，`2` 还可以表示 `b`……

通过上面的过程我们得到递归调用一个非常重要的性质——要返回。即递归调用结束之后我们总是要返回到上一层继续调用，每一层的递归调用都是如此，我们要逐步返回，直到在根节点的那次递归调用的所有可能性都尝试完成，我们整个的递归函数才结束。也正是如此我们这种递归尝试寻找答案的规程也被称之为 **回溯**。

也就是说我们沿着一条路径寻找答案，一旦找到答案或者没找到答案就回去继续找，以此类推，这个过程就是回溯。用这个概念看的话我们在上一章学习的跟树相关的算法，本质也是回溯，因为我们使用了递归，递归的话就需要返回。只不过 **回溯法** 这个词通常被用于问题是查找一个解。

上一节算法的时间复杂度大致是 `3^n = O(2^n)`，是一个指数级的算法，所以其效率是非常低的。我们来结合这棵树看，第一层有 3 种情况，第二层有 9 种情况，一直下去，是以指数级上升的。

**回溯法是暴力解法的一个主要实现手段。** 我们遇到是很多问题要枚举其所有可能，如果不能使用简单的循环遍历的话，就需要使用这种回溯法。

大家可以思考下对于这个问题的特点是什么，特点是对于 n 是一个变量。如果它的长度是固定的，比如 8，那我们就可以使用 8 重循环来枚举所有的可能性。但是现在长度是动态的，我们就可以使用这种回溯法来枚举所有的可能性。我们后面会看到动态规划也是在回溯法的基础上构建的。

有些问题我们只能使用回溯法这种暴力解法来解决，但是在回溯的过程中我们可以通过 **剪枝** 不用到达所有的的叶子节点，从而提高算法效率，后面我们将接触到。

## 相关问题

> [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)
>
> 给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 `s` 获得的 **有效 IP 地址** 。你可以按任何顺序返回答案。
>
> **有效 IP 地址** 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。
>
> 例如："0.1.2.201" 和 "192.168.1.1" 是 **有效** IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 **无效** IP 地址。



> [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)
>
> 给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。
>
> **回文串** 是正着读和反着读都一样的字符串。



# 排列问题 Permutations

















组合问题 Combinations
回溯法解决组合问题的优化
二维平面上的回溯法 Word Search
floodfill 算法，一类经典问题 Number of Islands
回溯法是经典人工智能的基础 N Queens