# 一、网络基础

## OSI 七层网络模型

国际标准化组织 ISO 制定的 OSI 七层协议模型是业界提出来的概念型框架，是不断迭代出来的，下面看看七层协议是如何进化来的。

![](https://img-blog.csdnimg.cn/2021010409370574.gif)

我们首先要解决两台物理机之间的通信需求，具体就是机器 A 往机器 B 发送比特流，机器 B 能收到这些比特流，这便是物理层要做的事情。物理层主要定义了物理设备的标准，有网线的类型，光纤的接口类型，各种传输介质的传输速率等。它的主要作用，是传输比特流即我们所谓的 0101 二进制数据，让他们转化为电流强弱来进行传输，到达目的地后再转化为的机器码，也就是我们常说的数模转换与模数转换，这层的数据叫做比特。网卡就是工作在这一层里面的。

第二层是数据链路层，在传输比特流的过程中会产生错传、数据传输不完整的可能，因此数据链路层应运而生。数据链路层定义了如何格式化数据进行传输，以及如何控制对物理介质的访问，这一层，通常还提供错误检测和纠正，以确保数据传输的可靠性。本层将比特数据组成了帧，其中，交换机工作在这一层里面，会帧解码，并根据帧中包含的信息把数据发送到正确的接收方。

那随着网络节点的不断增加，点对点通信的时候是需要经过多个节点的，那么如何找到目标节点，如何选择最佳路径便成为了首要需求，此时便有了网络层。这是我们的第三层，将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接受方。综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费，来决定从一个网络中节点 A 到另一个网络中节点B的最佳路径。由于网络层处理并智能指导数据传送，路由器连接网络各段，所以路由器属于网络层，此层的数据我们称之为数据包，本层我们需要关注的协议主要是 TCP/IP 协议里的IP协议。

那么随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输的可能需要很长时间，而网络在通信的过程中会中断好多次，此时为了保证传输大量文件时的准确性，需要对发出去数据进行切分，切割为一个一个的段落即 segment 进行发送，那么其中一个段落丢失了该怎么办？要不要重传？每个段落要按照顺序到达吗？这个便是传输层需要考虑的问题了。传输层解决了主机间的数据传输，数据间的传输可以是不同网络的，并且解决了传输质量的问题，称之为 OSI 模型中最重要的一层。传输协议同时进行流量控制，或是基于接收方可接收数据的快慢程度规定适当的发送速率，除此之外，传输层按照网络能处理的最大尺寸，将较强的数据包进行强制分割，例如以太网无法接收大于 1500 字节的数据包，发送方节点的传输层，将数据呢分割成较小的数据片，同时对每一数据片安排序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组，该过程即称为排序传输。传输层中需要关注的协议有 TCP/IP 协议中的 TCP 协议和 UDP 协议。

现在我们已经保证给正确的计算机发送正确的封装过后的信息了，但是用户级别的体验好不好，难道我每次都要去调用 TCP 去打包，然后就要用 IP 协议去找路由自己去发？当然不行，所以我们要建立一个自动收发包、自动寻址的功能，于是发明了会话层。会话层的作用，就是建立和管理应用程序之间的通信。

现在我能保证应用程序自动收发包和自动寻址了，但我要用 Linux 给 windows 发包，两个系统语法不一致，于是需要表示层帮我们解决不同系统之间的通信语法的问题，在表示层将数据将按照网络能理解的方案进行格式化，这种格式化也因所使用网络的类型不同而不同。

此时，虽然发送方知道自己发送的是什么东西转化成字节数据之后有多长，但接收方肯定不知道，所以应用层的网络协议诞生了，它规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，而且消息投影必须记录消息体的长度等一系列信息，以方便接收方能够正确的解析发送方发送的数据。应用层旨在让你更方便的应用从网络中接收到的数据，至于数据的传递，没有该层你也可以直接在两台电脑间开干，只不过传来传去就是1和0组成的字节数组。该层需要我们重点去关注的是 TCP/IP 协议中的 HTTP 协议。

![](https://z3.ax1x.com/2021/07/09/RjejVx.png)

以上就是关于 OSI 各层次的划分，那从应用层开始都会对要传输的数据头部进行处理，加上本层的一些信息，最终由物理层通过以太网电缆等介质，将数据解析成比特流在网络中传输。数据传递到目标地址，并自底而上的将先前对应层的头部给解析分离出来，这个就是我们的网络数据处理的整个流程。

## TCP/IP 四层网络模型

OSI 是一个定义良好的协议规范级，并有许多可选部分完成类似的任务，它定义了开放系统的层次，结构层次之间的相互关系以及各层所包括的可能的任务，是作为一个框架来协调和组织各层所提供的服务。但是 OSI 参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的制定。 即 OSI 参考模型，并不是一个标准，而是一个在制定标准时所使用的概念性框架。事实的标准是 TCP/IP 四层架构参考模型。

![](https://img-blog.csdn.net/20170822222325781)

TCP/IP 参考模型是计算机网络的祖父ARPANET和其后继的因特网使用的参考模型，市面上绝大多数厂商也以该标准为主，该模型并不完全符合 OSI 的七层参考模型，但我们依然可以理解为它是 OSI 的一种实现。接下来咱们来讲讲这个主流的协议。

从字面上讲，有人可能会认为， TCP/IP 是指TCP和IP这两种协议，实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用IP进行通信时所必须用到的协议群的统称，具体来说IP、icmp、TCP、udp、telnet或者FTP，都属于 TCP/IP 协议。 TCP/IP 与 OSI 在分层模块上稍有区别， TCP/IP 的应用程序可以理解为约等于 TCP/IP 中的应用层、表示层和会话层的组合，同时 OSI 的数据链路层以及物理层在 TCP/IP 中被规定为链路层。 OSI 模型注重通信协议必要的功能是什么，而 TCP/IP 则更强调在计算机上实现协议应该开发哪种程序。

![](https://img-blog.csdn.net/20160802112022872)

从另外一张图里，在数据传输的过程中，我们可以看到和 OSI 一样， TCP/IP 的每个过程中，都会对所发送的数据附加一个头部，在这个头部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常为协议提供的信息为报头的头部，所要发送的内容为数据。从下一层角度上看，数据被传送到接收端之后，再层层解套出来。

## 参考

- [ OSI 七层模型详解](https://blog.csdn.net/yaopeng_2005/article/details/7064869)
- [ TCP/IP 四层模型](https://blog.csdn.net/csdn_kou/article/details/82910753)
- [ OSI 七层协议模型、 TCP/IP 四层模型和五层协议体系结构之间的关系](https://blog.csdn.net/wxb880114/article/details/82751680)
- [ OSI 七层模型与 TCP/IP 五层模型](https://www.cnblogs.com/qishui/p/5428938.html)

# 二、TCP 三次握手

## 传输控制协议 TCP 简介

- 面向连接的、可靠的、基于字节流的传输层通信协议
- 将应用层的数据流分割成报文段并发送给目标节点的 TCP 层
- 数据包都有序号， 对方收到则发送 ACK 确认， 未收到则重传
- 使用校验和来检验数据在传输过程中是否有误

## TCP 报文头部

![image-20210819020841734](https://z3.ax1x.com/2021/08/19/f76ASg.png)

- Source Port 、Destination Port：分别表示原端口和目的端口
- Squence Number：序列号
- Acknowledgment Number：确认号
- Offset：数据便宜，由于头部有可选字段，长度不固定，因此它指出 TCP 报文的数据距离 TCP 报文的起始处有多远
- Reserved：保留域
- TCP Flags
  - URG：紧急指针标志
  - ACK：确认序号标志
  - PSH：push 标志
  - RST：重置连接标志
  - SYN：同步序号，用于建立连接过程
  - FIN：finish 标志，用于释放连接
- Window：滑动窗口的大小，用来告知发送端接收端的缓存大小，依次控制发送端发送数据的速率，从而达到流量控制
- Checksum：检验和，有发送端进行存储，并由接收端进行验证
- Urgent Pointer：紧急指针，只有当 TCP Flags 中的 URG 为 1 时才有效，指出本报文段中紧急数据的字节数
- TCP Opions：可选项，其长度可变，定义一些其他的可选参数

## 三次握手过程

![image-20210819024919532](https://z3.ax1x.com/2021/08/19/f7cE4K.png)

在 TCP/IP 协议中, TCP 协议提供可靠的连接服务,采用三次握手建立一个连接。

1. 第一次握手：建立连接时,客户端发送 SYN 包（syn=j）到服务器，并进入 SYN-SEND 状态，等待服务器确认；
2. 第二次握手：服务器收到 SYN 包，必须确认客户的 SYN（ack-j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；
3. 第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK（ack-k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。

## 为什么需要三次握手才能建立起连接

为了初始化 Sequence Number（序列号）的初始值，双方都会生成自己的 Sequence Number，并需要告知对方，作为以后通讯的序号，以保证在网络传输过程，不会因为网络原因而导致乱序。

## 首次握手的隐患 - SYN 超时

问题起因分析：

Server 收到 Client 的 SYN 回复 SYN-ACK，如果此时 Client 掉线或者异常未发出 ACK，Server 没有收到 ACK 确认，那么这个连接就会处于一个中间状态，既没有成功也没有失败。Server 就会不断重发 SYN-ACK 直至超时，Linux 下默认重试 5 次，间隔时间初次为 1s，之后每次都翻倍，5 次失败后总共需要等待 63 秒才断开连接。

这种情况使服务器可能会遭到 SYN Flood 攻击的风险，恶意程序向服务器发送 SYN 报文，然后就下线了，服务器需要等 63s 才会断开连接，这样攻击者就能将服务器的 SYN 连接队列耗尽，使服务器不能处理正常的连接请求。

针对 SYN Flood 的防护措施：

Linux 下提供了一个 `tcp_syncookies` 的参数，当 SYN 队列满后，TCP 会通过源地址端口、目标地址端口和时间戳打造出一个特别的 Squence Number 回发回去，简称 SYN Cookie。如果是攻击者，是不会有相应的，如果是正常连接，则会把 SYN Cookie 发回来，服务端可以通过 Cookie 直接建立连接。通过 SYN Cookie，即便 SYN 队列满了，本次连接请求不在队列中，依然可以建立连接。

## 建立连接后, Client 出现故障怎么办

TCP 设有保活机制，若在在一段时间内连接处于非活动状态，开启保活功能的一端将向对方发送保活探测报文，如果未收到响应则继续发送，直到尝试次数达到保活探测数仍未收到响应，则中断连接。

# 三、TCP 四次挥手

## 四次挥手过程

![image-20210819024831703](https://z3.ax1x.com/2021/08/19/f7cAN6.png)

TCP 采用四次挥手来释放连接，数据传输完毕之后，双方都可以释放连接，这里以客户端主动关闭为例。

1. 第一次挥手：Client 发送一个 FIN，用来关闭 Client 到 Server 的数据传送，Client 进入 FIN_ WAIT_1状态；
2. 第二次挥手：Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为收到序号 +1（与 SYN 相同，一个 FIN  占用一个序号），Server 进入 CLOSE_WAIT 状态；
3. 第三次挥手：Server 发送一个 FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态；
4. 第四次挥手：Client 收到 FIN 后，Client 进入 TIME_WAIT 状态，接着发送一个 ACK 给 Server，确认序号为收到序号 +1，Server 进入 CLOSED 状态，完成四次挥手。

注意，Client 发送最后一次 ACK 后，并没有直接进入关闭状态，二是 TIME-WAIT，时间是 2MSL。MSL，即最长报文段生命。而 Server 端收到 Client 的最后一次 ACK 后就直接关闭连接了。

## 为什么会有 TIME WAIT 状态

主要有两个原因：

- 确保有足够的时间让对方收到 ACK 包。如果被动关闭放没有收到最后一次 ACK，就会触发重发 FIN 包，一来一去正好是两个 MSL。
- 避免新旧连接混淆。因为有些路由器会缓存 IP 数据包，如果连接被重用了，那么这些延迟收到的包就有可能跟新连接混在一起。

## 为什么需要四次握手才能断开连接

因为全双工允许数据在两个方向上同时传输，即在同一时间，客户端可以发送数据给服务端，服务端也可以发送数据给客户端。因为 TCP 是全双工的，要保证数据都传输完了，发送方和接收方都需要 FIN 报文和 ACK 报文，也就是发送方和接收到各需要两次挥手。

## 服务器出现大量 CLOSE_WAIT 状态的原因

对方关闭 socket 连接，我方忙于读或写，没有及时关闭连接。碰到这种情况，多数是因为程序有 bug。

- 检查代码，特别是释放资源的代码
- 检查配置，特别是处理请求的线程配置

# 四、UDP 和 TCP 的区别

## UDP 报文结构

![image-20210819025217451](https://z3.ax1x.com/2021/08/19/f7cQHI.png)

## UDP 的特点

- 面向非连接。传输数据时，源端和终端不建立连接，发送简单的抓取应用程序数据，并尽可能快的发到网络中；接收端收到数据后将数据放到队列中，应用程序每次从队列中读取一个消息段。
- 不维护连接状态，支持同时向多个客户端传输相同的消息
- 数据包报头只有 8 个字节，额外开销较小
- 吞吐量只受限于数据生成速率、传输速率以及机器性能
- 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表
- 面向报文，不对应用程序提交的报文信息进行拆分或者合并，因此应用程序需要选择合适的报文大小

## UDP 和 TCP 的区别

 TCP 和 UDP 是 OSI 模型中传输层的协议，TCP 提供可靠的通信传输，而 UDP 则常被用于让网络和细节控制交给应用层的通信传输，两者的区别如下：

- **面向连接 vs 无连接**：TCP 有三次握手的连接过程；UDP 适合消息的多播发布。
- **可靠性**：TCP 利用握手、确认和重传机制保证可靠性；UDP可能丢失报文。
- **有序性**：TCP 利用序列号保证了报文的顺序性；而 UDP 不具备有序性
- **速度**：TCP 要创建连接，保证数据可靠性和有序性等，较慢；UDP 没有这些操作，更适合队速度敏感的应用。
- **量级**：TCP 属于重量级的，UDP 属于轻量级的，体现的元数据的头大小，TCP 是 20 个字节，UDP 是 8 个字节。

# 五、TCP 滑动窗口

## RTT 和 RTO

解释滑动窗口前，先弄清楚 TCP 的两个概念，**RTT** 和 **RTO**。

- RTT：**一个数据包到收到应的 ACK 所花费的时间。**RTT 的计算很简单，就是一个时间差。
- RTO：**重传时间间隔。**TCP 在发送一个数据包后，会启动一个重传定时器，RTO 就是这个重传定时器的时间。简单来说，TCP 预先算出一个重传时间，如果时间范围内收到了 ACK，重传定时器就失效，否则时间到了之后进行数据重传。RTO 需要不是固定的，是通过 RTT 计算出来的。基于 RTO 便有了重传机制，才有了接下来的滑动窗口。

## TCP 滑动窗口特性

TCP 会将数据拆分成段发送，出于效率考虑我们不可能等上一段数据被确认后再发下一段数据，要实现数据的批量发送，TCP 必须解决数据的可靠传输以及包段序的问题。所以 TCP 需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞导致丢包。**TCP 使用滑动窗口做流量控制与乱序重排。**

TCP 滑动窗口的两个特性：

- 保证 TCP 的可靠性
- 保证 TCP 的流控特性

TCP 报文头部有一个 window 字段，用于接收方通知发送方自己还有多少缓冲区可以接受数据，发送方根据接收方的处理能力来发送数据，不会导致接收方处理不过来，这便是流量控制。同时，滑动窗口机制还体现了 TCP 面向字节流的设计思路。

## 窗口数据的计算过程

如图所示，左右分别是发送端程序缓冲区和接收端程序缓冲区，左边往右边发数据，下面的长方向表示要发送的数据流，并且需要按照顺从左往右发送或者接收

对于接收方：

- LastByteAcked：指向收到的连续最大的 ACK 位置，即确认被接收端收到的连续最后字节位置。
- LastByteSent：指向已经发送的位置，即已发送但还为收到 ACK 的最后字节位置
- LastByteWritten：指向上层应用程序一写入数据的位置，即已经准备好待发送数据的最后字节位置。

对于发送方：

- LastByteRead：指向上层应用已经读完的最后一个字节位置，以己经收到并 ACK 的最后字节位置。
- NextByteExpected：连续收到的最大 Sequence 位置，即收到数据但没 ACK 的最后字节位置。
- LastByteRcvd：已收到的最后一个字节的位置。



![image-20210823222835751](https://z3.ax1x.com/2021/08/23/hiEcK1.png)

可以看到接收方缓冲区 NextByteExpected 和 LastByteRcvd 中间有一段空白区域，表示这一段的数据还没到达。此时根据上面的数据可以计算出接收方的可接受大小 Advertiesd Window，回发给发送方，让其计算出发送方剩余可发送大小 Effective Window，计算公式如下：

- `Advertised Window = MaxRcvBuffer - ( LastByteRcvd - LastByteRead )`，即可接收大小 = 接收缓冲区最大容量 - （最大接收位置 - 最大已处理位置）
- `EffectiveWindow = AdvertisedWindow - ( LastByteSent - LastByteAcked )`，即可发送发小 = 可接收大小 - （最大已发送位置 - 最大已确认位置）

通过上述运算，才能保证接收方能处理发送过来的数据。

## TCP 滑动窗口的基本原理

对于 TCP 发送方，任何时候在其发送缓存内的数据都可以分成四个状态：

- 发送并已确认的（Category #1）
- 发送但未确认的（Category #2）
- 未发送但允许发送的（Category #3）
- 未发送但由于达到 window 大小不允许发送的 （Category #4）

![image-20210823225542891](https://z3.ax1x.com/2021/08/23/hin16H.png)

其中 Category 2 和 Category 3 组成的连续空间就是发送窗口，当收到新的 ACK 后，窗口就会进行滑动，如下图所示。收到一部分数据的 ACK 后，等量的不允许发送的数据（Category #4）就变为允许发送的数据，发送方串口滑动。

![image-20210823225934491](https://z3.ax1x.com/2021/08/23/hiuVgg.png)

对于 TCP 接收方，在同一时刻在其接收缓存内有三种数据状态:

- 已接受并以 ACK（Category #1+2）
- 未接受但可以接收，即准备接收（Category #3）
- 未接受并且不能接收，因为达到窗口阈值（Category #4）

![image-20210823230206089](https://z3.ax1x.com/2021/08/23/hiu056.png)

接收方滑动窗口为绿色部分（Category #3），当左侧数据接收到并回送了 ACK 后，窗口向右滑动。

经过上面的分析我们得知，TCP 更近精准的传输可靠新来源于确认重传机制，TCP 滑动窗口的可靠性，也是建立再确认重传机制的基础上的。发送窗口要收到接收方连续 ACK 才会滑动窗口左边界，接收方窗口只有在前面所有的段都确认的情况下才会移动左边界，再前面数据段未接受但后面有数据段已接受的情况下，窗口是不会滑动的，以此确保对方会对这些数据重传。

# 六、HTTP

## HTTP 主要特点

- 支持客户/服务器模式
- 简单快速
- 灵活
- 无连接：是指每次链接只处理一个请求，服务器处理完客户端的请求，并受到客户端应答后及就开连接。
- 无状态：是指协议对数据处理没有记忆能力，缺少状态意味着后续处理需要前面信息，则需要重传。

## 请求／响应报文结构

HTTP 请求结构：

![image-20210823232008298](https://z3.ax1x.com/2021/08/23/hiMsnH.png)

HTTP 响应结构

![image-20210823231849893](https://z3.ax1x.com/2021/08/23/hiMY7R.png)

## 请求／响应的步骤

1. 客户端与 Web 服务器建立 TCP 连接

2. 客户端发送 HTTP 请求

3. 服务器接受请求并返回 HTTP 响应

4. 释放连接 TCP 连接

   > 如果非 keeplive，服务端主动断开连接，客户端被动关闭。如果为 keeplive，则该连接会保持一段时间，该时间内可以继续接收请求。

5. 客户端浏览器解析 HTML 内容

## 在浏览器地址栏键入 URL，按下回车之后经历的流程

1. DNS 解析
2. TCP 连接
3. 送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 连接结束

其中第 5、6 步骤可以说同时发生，没有顺序要求。

HTTP 状态码

- 1xx：指示信息——表示请求已接收,继续处理
- 2xx：成功——表示请求已被成功接收、理解、接受
- 3xx ：重定向——要完成请求必须进行更进一步的操作
- 4xx ：客户端错误——请求有语法错误或请求无法实现
- 5xx ：服务器端错误——服务器未能实现合法的请求

## GET 请求和 POST 请求的区别

从三个层面来解答

- HTTP 报文层面：GET 将请求信息放在 URL，POST 放在报文体中
- 数据库层面：CET 符合幂等性和安全性，POST 不符合
- 其他层面：GET 可以被缓存、被存储，而 POST 不行

## Cookie 和 Session 的区别

HTTP 无状态的，导致客户端和服务端对彼此的数据交互没有记忆性。需要引入某些机制让 HTTP 具备状态，其中的两个就是 Cookie 和 Session。

### Cookie 简介

Cookie 的客户端解决方案

- 是由服务器发给客户端的特殊信息，以文本的形式存放在客户端
- 客户端再次请求的时候，会把 Cookie 回发
- 服务器接收到后，会解析 Cookie 生成与客户端相对应的内容

Cookie 的设置以及发送过程如下：

![image-20210823233527411](https://z3.ax1x.com/2021/08/23/hilrTA.png)

1. 客户端发送一个 HTTP 请求到服务端
2. 服务端返回相应，其中包括了 `Set-Cookie` 的头部
3. 客户端再次请求服务端就会带上指定的 `Cookie` 头部

### Session 简介

- 服务器端的机制，在服务器上保存的信息
- 解析客户端请求并操作 session id，按需保存状态信息

Session 的实现方式

1. 使用 Cookie 来实现

   服务器为每个 Session 分配一个 JSESSIONID，并通过 Cookie 发送给客户端，后续客户端请求将在 Cookie 头中携带 JSESSIONID，这样服务器能找到客户端对应的 Session。

   ![image-20210823233856219](https://z3.ax1x.com/2021/08/23/hilXXF.png)

2. 使用 URL 回写来实现

   URL 回写指服务器再发送给浏览器页面的所有连接中都携带 JSESSIONID 的参数，这样客户端点击任何一个连接，都会把 JSESSIONID 带回服务器。如果直接在浏览器输入资源 URL，Session 是匹配不到的。

Tomcat 对 Session 的实现的一开始同时使用 Cookie 和 URL 回写机制，如果发现客户端支持 Cookie 就继续使用 Cookie，停止使用 URL 回写；如果发现 Cookie 被禁用，就一直使用 URL 回写。

### Cookie 和 Session 的区别

- Cookie 数据存放在客户的浏览器上，Session 数据放在服务器上
- Session 相对于 Cookie 更安全
- 若考虑减轻服务器负担，应当使用 Cookie

# 七、HTTPS

## HTTPS 和 SSL

HTTPS 是一种以计算机网络安全通信为目的的传输协议，在 HTTP 下面加入了 SSL 层，从而具有了保护交换数据隐私以及完整性以及完整性，还有提供对网站服务器身份认证的功能。简单来说就是安全版的 HTTP。

![image-20210823234857792](https://z3.ax1x.com/2021/08/23/hi3E80.png)

首先来了解下 SSL（Security Sockets Layer，安全套接层）

- 为网络通信提供安全及数据完整性的一种安全协议
- 是操作系统对外的 API，SSL 3.0 后更名为 TLS
- 采用身份验证和数据加密保证网络通信的安全和数据的完整性

## 常见加密的方式

- 对称加密：加密和解密都使用同一个密钥
- 非对称加密：加密使用的密钥和解密使用的密钥是不相同的
- 哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆
- 数字签名：证明某个消息或者文件是某人发出/认同的

## HTTPS 数据传输流程

- 浏览器将支持的加密算法信息发送给服务器
- 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器
- 浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器
- 服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器
- 浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据

## HTTP 和 HTTPS 的区别

- HTTPS 需要到 CA 申请证书，HTTP 不需要
- HTTPS 密文传输，HTTP 明文传输
- 连接方式不同，HTTPS 默认使用 443 端口，HTTP 使用 80 端口
- HTTPS = HTTP + 加密 + 认证 + 完整性保护，较 HTTP 安全

> 引申：HTTPS 真的很安全吗，那倒未必
>
> - 浏览器默认填充 `http://` 请求需要进行跳转，有被劫持的风险
> - 可以使用 HSTS（ Http Strict Transport Security）优化

# 八、Socket

我们知道两个进程，如果需要进行通信，最基本的前提是要唯一标识一个进程。在本地进程通信中，我们可以使用PID来，唯一标识一个进程。但是PID仅在本地唯一，网络中的两个进程，PID可能冲突，这时候我们需要另辟蹊径。我们知道IP层的IP地址可以唯一标识一台主机，而TCP协议的端口号可以唯一标识一个进程，这样我们可以使用 IP地址 + 协议 + 端口号 来唯一标识网络中的一个进程。能为标示网络中的一个进程后，他们就可以利用 Socket 进行通讯了。 

![image-20210824071451926](https://z3.ax1x.com/2021/08/24/his2Lj.png)

什么是 Socket？实际上 Socket和 TCP/IP 协议并没有必然的联系。Socket 编程接口在设计的时候就希望能适应其他的网络协议，所以说 Socket 的出现只是使得程序员更方便的使用 TCP/IP 协议栈而已，是对 TCP/IP 协议的抽象，从而形成了我们所知道的最基本的函数接口。Socket 起源我 Unix，而 Unix 遵从一切皆文件的哲学，Socket 的一种基于打开，到读写，再到关闭的这种模式去实现的，服务器和客户端各自维护一个文件，在建立连接打开后，可以向自己文件写入内容，共对方读取或者读取对方内容，在通信结束时关闭文件。

Socket 通信流程：

![image-20210824071429915](https://z3.ax1x.com/2021/08/24/hisgyQ.png)

1. 服务器创建 Socket，并为 Socket 绑定端口号，紧接着服务器的 Socket 就会监听端口号请求，随时准备接收客户端发来的连接。此时服务器的 Socket 只是 listen，并没有打开。
2. 客户端创建 Socket 并打开，并使用 ip 地址和端口号尝试连接服务器 Socket。
3. 服务器 Socket 接收到客户端连接请求被动打开，开始接收客户端请求，知道客户端返回连接信息。此时服务端 Socket 进入阻塞状态，即 accept 方法需要一直等待客户端返回连接信息后才返回，同时开始接收下一个客户端连接请求。
4. 客户端在连接成功后就会向服务器发送连接状态信息，服务器接收到客户端的连接状态信息后就会将 accept 方法返回并提示连接成功，之后客户端就可以向 Socket 写入数据，服务器就能收到并读取相关数据。
5. 最后发送完数据后，客户端就会关闭 Socket，接着服务端也需要关闭 Socket。