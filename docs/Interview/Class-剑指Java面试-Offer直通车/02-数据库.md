# 一、架构

## 如何设计一个关系型数据库？

> 设计一个数据库就跟设计一款软件差不多，也是将其分界成很多模块，面试官问这个也主要是想考查我们的模块划分能力以及对数据库的了解。记忆一个东西的最佳方式便是站在设计者的角度去设计它。

![image-20210817002508406](https://z3.ax1x.com/2021/08/17/fhpWtg.png)

**答：**要设计一个关系型数据库，首相要将其划分成两大部分。一个是存储部分，该部分类似一个文件系统，来将数据持久化到存储设备中。还需要一个程序实例模块，来对存储进行逻辑上的管理。而程序实例模块将包含：

- 将数据的逻辑关系转换成物理储存的存储管理模块
- 优化执行效率的缓存模块
- 将 SQL 语句进行解析的 SQL 解析模块
- 记录操作的日志管理模块
- 进行多用户管理的权限划分模块
- 灾难恢复模块
- 优化数据查询效率的索引模块
- 使数据库支持并发操作的锁模块

# 二、索引

## 为什么要使用索引？

要回答这个问题，咱们先来对数据的查询方式做个调研，先试试最简单的查询方式，即全表扫描。它是将整张表的内容全部或分批次加载到内存中。MySQL 存储的最小单位是块或者页，它们是由多行数据组成的，然后我们将这些块都加载进来，然后逐个块去轮询，找到我们要的目标并返回。这种方式普遍被认为是非常的慢的。

全表扫描在所有的情况下都这么慢吗？存在即合理，它也有很适用的地方，当只有很少量的数据，全部加载到内存里进行全表扫描要比后面说的使用索引的方式要快。当然如果在数据量大的情况下，这种方式显然不适用了。因此这里就引出了我们的答案，很多情况下，我们都需要避免全表扫描的情况发生，索引数据库要引入一种更高效的机制，这便是索引。

索引的灵感来自于字典，依据字母很快就能定位到要查找的内容。而这些定位数据的关键信息便组成了索引，通过索引来大幅提升查询的速度便是问题的答案。但是仅仅这么回答不能让面试官满意，还需要结合后面的内容。

## 什么样的信息能成为索引？

能把数据记录限定在一定查找范围内的字段，主键便是一个很好的切入点，还有唯一键及普通键等。

## 索引的数据结构？

索引数据结构的选择，有以下几种方案

- 生成索引，建立二又查找树进行二分查找
- 生成索引，建立B-Tree结构进行查找
- 生成索引，建立B+-Tree结构进行查找
- 生成索引，建立Hash结构进行查找

接下来我们将各种数据结构用在索引上，一体现其优势和劣势，之后再更为详细地回答问题。

**二叉查找树上阵**

如下图左边所示，模拟使用二叉查找树来生成索引，每个节点存储一个数据和两个指针。二叉查找树使用二分查找查询数据，确实能够提高查询效率，时间复杂度是 O(logN)。但是当数据增加或者删除的时候，例如删除节点 2 和 6 的数据，增加节点 13，二叉树就变成了下图右所示，此时查询的时间复杂度变成了 O(N)，大大降低了查询效率。

![image-20210817013002079](https://z3.ax1x.com/2021/08/17/fhpRAS.png)

有同学可能会说使用树的旋转保证二叉树平衡，就可以维持查询复杂度为 O(logN)。这样确实解决了第一个问题，但是还会有第二个问题。二叉树或者红黑树只能有两个孩子，因此为了组织数据块，索引树的深度就会很深，查询一个数据的查找深度也会很深，影响查询效率。

**B 树**

B 树是一种多路查找树，如果每一个节点最多有 m 个孩子，这样 B 树就是 m 阶 B 树。下图就是一个三阶 B 树。

 ![image-20210817014058573](https://z3.ax1x.com/2021/08/17/fhpg78.png)

对于一个 m 阶 B 树，有以下特征：

- 根节点至少包括两个孩子
- 树中每个节点最多含有 m 个孩子（m>=2）
- 除根节点和叶节点外，其他每个节点至少有 ceil(m/2) 个孩子（ceil 向上取整）
- 所有叶子节点都位于同一层

与其说是特征，不如说是 B 树必须遵守的一个约定，目的就是让每个索引节点存储尽可能多的信息，尽可能减少树的高度，减小查找深度。

最后 B 树还有以下特征：

![image-20210817015343873](https://z3.ax1x.com/2021/08/17/fh9Sj1.png)

以搜索元素 15 为例，讲述 B 树查找元素过程：首先找根节点 `node1(17, 35)`，15 < 17，所以找 17 左边的指针 P1 指向的节点  `node2(8, 12)`，15 > 12，找 12 右边指针 P3 指向的节点 `node3(13, 15)`，至此找到了元素 15。

B 树的查找效率同样是 O(logN)，B 树中增加删除节点时，有其相应的策略，通过合并分裂上一下一节点来维持其特性，让其始终平衡。

**B+ 树**

B+ 树是 B 树的变体，其定义基本与 B 树相同，除了：

- 非叶子节点的子树指针与关键字个数相同
- 非叶子节点的子树指针 `P[i]`，指向关键字值 `[ K[i], K[i+1] )` 的子树
- 非叶子节点仅用来索引，数据都保存在叶子节点中
- 所有叶子节点均有一个链指针指向下一个叶子结点

![image-20210817020915150](https://z3.ax1x.com/2021/08/17/fh91US.png)

> 非叶子节点不存储数据，这样就可以存更多的关键字了，这就使得 B+ 树相对于 B 树来说更矮。B+ 树所有叶子节点链接起来，使得其支持范围查找。

为什么 B+Tree 更适合用来做存储索引：

1. B+ 树的磁盘读写代价更低
2. B+ 树的查询效率更加稳定
3. B+ 树更有利于对数据库的扫描

**Hash 索引也可以考虑以下**

Hash 索引使用 Hash 函数的运算，只需一次就能定位数据所在的头。

![image-20210817022608488](https://z3.ax1x.com/2021/08/17/fh9sC4.png)

缺点：

- 仅仅能满足 “="，“IN"，不能使用范围查询
- 无法被用来避免数据的排序操作
- 不能利用部分索引键查询
- 不能避免表扫描
- 遇到大量 Hash 值相等的情况后性能并不一定就会比 B-Tree 索引高

**BitMap 索引是个神奇**

目前很少有数据库都支持位图索引，比较主流的是 Oracle。

![image-20210817022802418](https://z3.ax1x.com/2021/08/17/fh9629.png)

## 密集索引和稀疏索引的区别？

**密集索引文件中的每个搜索码值都对应一个索引值**

叶子节点保存的不仅仅是键值，还保存了同行记录的其他列信息。密集索引决定了表的配列顺序，一个表只能有一个排列顺序，所以一个表只能创建一个密集索引。

![image-20210817225349374](https://z3.ax1x.com/2021/08/17/fIEg2V.png)

**稀疏索引文件只为索引码的某些值建立索引项**

叶子节点仅保存了键位信息以及该行数据的地址，有的稀疏索引的紧保存了键位信息以及主键。定位到叶子节点后，任然需要通过地址或者主键进一步定位到数据。

![image-20210817225455923](https://z3.ax1x.com/2021/08/17/fIEIa9.png)

以上是一般数据库的情况，下面开始对 MySQL 做具体分析。MyISAN 中的索引均属于稀疏索引，而 InnoDB 必须有且仅有一个密集索引，InnoDB 的密集索引选取规则如下：

- 若一个主键被定义，该主键则作为密集索引
- 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引
- 若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）
- 非主键索引存储相关键位和其对应的主键值，包含两次查找

下图为 InnoDB 和 MyISAM 中通过索引查找数据的过程

![image-20210817231210239](https://z3.ax1x.com/2021/08/17/fImKJA.png)

对于物理文件而言，InnoDB 中索引和数据是存在一起的，而 MyISAM 中索引和数据是分开存储的。如下图所示使用 InnoDB 的 `person_info_large` 表和使用 MyISAM 的 `shop_info_small` 表，其中 `frm` 文件存储表结构。

![image-20210817231851675](https://z3.ax1x.com/2021/08/17/fInZ60.png)

## 如何定位并优化慢查询

步骤：

1. 根据慢日志定位慢查询 sql
2. 使用 explain 等工具分析 sql
3. 修改 sql 或者尽量让 sql 走索引

下图是慢查询日志的内容

![image-20210817234553183](https://z3.ax1x.com/2021/08/17/fIMLHf.png)

## 联合索引的最左匹配原则的成因

什么是联合索引的最左匹配原则：

- **最左前缀匹配原则**，mysql 会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配，比如 `a=3 and b=4 and c>5 and d=6` 如果建立 `(a,b,c,d)` 顺序的索引，d 是用不到索引的，如果建立 `(a,b,d,c)` 的索引则都可以用到，a、b、d 的顺序可以任意调整。
- `=` 和 `in` 可以乱序，比如 `a=1 and b=2 and c=3` 建立 `(a,b,c)` 索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。

联合索引的最左匹配原则的成因：

MySQL 在创建联合索引的规则，是首先对联合索引的第一个字段进行排序，在第一个字段排序的基础上在对第二个字段进行排序，依次类推。多以联合索引的第一个字段是绝对有序的，之后的字段都是在前一个字段的基础上小范围再排序，所以跳过之前的字段是无法使用到后面字段的索引的。

## 索引是建立得越多越好吗

- 数据量小的表不需要建立索引，建立会增加额外的索引开销
- 数据变更需要维护索引，因此更多的索引意味着更多的维护成本
- 更多的索引意味着也需要更多的空间

# 三、锁

## MyISAM 与 InnoDB 关于锁方面的区别是什么

先给出答案：

- MyISAM 默认用的是表级锁，不支持行级锁
- InnoDB 默认用的是行级锁，也支持表级锁

!> InnoDB 在 sql 用到索引的时候加的是行级锁和间隙锁，sql 没有用到索引的时候用的加的是表级锁

是不是行级锁一定比表级锁好呢？那倒未必，锁的粒度越细，代价越高。相比表级锁直接在表的头部加锁来讲，行级锁还需要扫描到某行的时候对其上锁，这样代价是比较大的。InnoDB 支持事务的同时，也相比 MyISAM 引擎带来了更大的开销。

## MyISAM 和 InnoDB 的适用场景

MyISAM 适合场景：

- 频繁执行全表 count 语句

  InnoDB 是不保存表的行数的，执行全表 count 时需要重新扫描统计；而 MyISAM 用一个变量保存了整个表的行数，执行 count 查询时只需要读出该变量，速度很快。

- 对数据进行增删改的频率不高，查询非常频繁

- 没有事务

InnoDB 适合场景：

- 数据增删改查都相当频繁
- 可靠性要求比较高，要求支持事务

## MySQL 锁的分类

- 按锁的粒度划分，可分为表级锁、行级锁、页级锁
- 按锁级别划分，可分为共享锁、排它锁
- 按加锁方式划分，可分为自动锁、显式锁
- 按操作划分，可分为DML锁、DDL锁
- 按使用方式划分，可分为乐观锁、悲观锁

InnoDB 默认支持行级锁，同时支持表级锁，InnoDB 对行级上锁时，会先上一种表级别的意向锁。MyISAM 仅支持表级锁，不常用的 BDB 引擎支持页级锁。

MySQL 执行语句自动加的锁是自动锁，而 `select ... for update` 和 `lock in share mode` 属于显示锁。

悲观锁：对数据被外界的修改持保守态度，因此在整个数据梳理过程中，将数据处于锁定状态。悲观锁的实现往往依靠数据库的锁机制。全程用排他锁锁定正是一种悲观锁的实现，悲观并发控制实际上是先取锁，再访问的保守策略，对数据处理的安全提供了保证。但是从效率而言，处理加锁的机制会让数据库产生二外的开销，增加产生死锁的机会。

乐观锁：乐观锁认为数据一般情况下不会产生冲突，所以在数据进行提交更新的时候才会正式对数据的冲突与否进行检测，如果发生冲突则返回错误信息给用户，让用户决定如果处理。乐观锁并不会使用数据库的锁机制，一般的乐观锁实现就是记录数据版本，即使用版本号或时间戳。

## 数据库事务的四大特性

- **原子性（Atomic）**：事务包含的操作要么全部MS执行，要么全部失败回滚。
- **一致性（Consistency）**：事务应确保数据库的状态从一个一致状态转变为另一个一致状态，一致性状态是指数据库中的数据应满足完整性约束。
- **隔离性（Isolation）**：多个事务并发执行时，一个事务的执行，不应该其他事务的执行。
- **持久性（Durability）**：一个事务一旦提交，它对数据库的修改应该永久保存在数据库中。持久性意味着当系统或者介质发生故障时，确保已提交事务的更新不能丢失，即对已提交事务的能恢复。一旦一个事务被提交，BDMS 必须保证提供适当的冗余，使其耐得住系统的故障，所以持久性主要在于 BDMS 的恢复性能。那 InnoDB 来讲，会将所有对数据的修改写入 redo_log，并在数据库启动时从此文件进行恢复操作，redo_log 保证了数据库的持久性。

## 事务隔离级别以及各级别下的并发访问问题

事务并发访问引起的问题以及如何避免

- 更新丢失 —— mysql 所有事务隔离级别在数据库层面上均可避免
- 脏读 —— READ-COMMITTED 事务隔离级别以上可避免
- 不可重复读 —— REPEATABLE-READ 事务隔离级别以上可避免
- 幻读 —— SERIALIZABLE 事务隔离级别可避免

![image-20210818012203586](https://z3.ax1x.com/2021/08/18/fIGRHI.png)

## InnoDB 可重复读隔离级别下如何避免幻读

这里分为表象和内在，表象是我们能看到的现象，并不是真正的原因，原因体现在内在。

- 表象：快照读（非阻塞读）—— 伪 MVCC
- 内在：next-key 锁（行锁 + gap 锁）

表象是在 RR 级别下，基于伪 MVCC 机制实现的快照读，来避免读到幻行。先来介绍下 **快照读** 和当 **前读取**。

- 当前读：select...lock in share mode，select...for update 
- 当前读：update，delete，insert
- 快照读：不加锁的非阻塞读，select

其实当前读就是加了锁的增删改查语句，为什么叫当前读呢，因为它都的是记录的最新版本，读取之后还需要保证其他并发事务不能修改当前记录，对读取的记录加锁。上述操作中，除了 `select...lock in share mode` 是加共享锁，其他的都是加的排他锁。为什么 update，delete，insert 也是当前读呢？

**（1）当前读介绍**

咱们了解到 RDBMS 组要由两大部分组成，程序实例和存储，下图中程序实例即 MySQL Server 的实例，存储是 InnoDB。我们拿图中 update 语句为例，分析流程：

![image-20210818013751556](https://z3.ax1x.com/2021/08/18/fIJGIP.png)

1. 当 sql 发给 MySQL 之后，MySQL Server 会根据 where 条件读取第一条满足条件的记录 （select row 1）
2. InnoDB 会将第一条记录返回并加锁（return & lock）
3. MySQL Server 接收到这条加锁的记录后，会发起一个 update 操作去更新这条记录（update row）
4. 一条记录更新完成后，再读取下一条记录，直至没有满足条件的记录为止（finished）

上图中，update 操作内部就包含了一个当前读（current read）来获取数据的最新版本。在 RC 隔离级别下，update 语句全表的时候，就能读到此事务过程中别的事务 insert 的记录，即读取到了数据的最新版本，同理 delete 操作也一样。而 insert 操作略由不同，简单来说就是 insert 操作可能会触发唯一键的冲突检查，所以也会进行一个当前读取。

**（2）快照读介绍**

快照读和当前读不同，它就是简单的 select 操作，不加锁。注意这是在事务隔离级别不为 SERIALIZABLE 的前提下，SERIALIZABLE 下由于是串行读，所以此时的快照读也退化成当前读，即 `select...lock in share mode` 模式。

之所以出现快照读，是基于提升并发性能的考虑，快照读是基于多版本并发控制，即 MVCC。可以认为 MVCC 是行级锁的一个变种，它在很多情况下避免了加锁操作，因此开销更低。既然是基于多版本，也就意味着快照读有可能读到的并不是数据的最新版本，可能是之前的历史版本。之所以说是可能，是因为 RR 隔离级别下，事务首次调用快照读的地方很关键，也就是创建快照的时机，决定了读取数据的版本。

## RC、RR 级别下的 InnoDB 的非阻塞读如何实现

InnoDB 在 RC、RR 级别下实现快照读离不开下面三个因子：

1. 数据行里的 DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID 字段
2. undo 日志
3. read view

下面一一介绍上述三个因子

**（1）DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID 字段**

- DB_TRX_ID：最后一次更新本行数据的事务 id
- DB_ROLL_PTR：回滚指针（db roll pointer），指向对应的 undo log
- DB_ROW_ID：行号，单调递增的行 id，当由 InnoDB 自动产生聚集索引时，聚集索引会包括这个行 id 的值，否则这个行 id 不会出现在任何索引中

**（2）undo 日志**

当我们对记录做了变更操作时便会产生 undo 记录，记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读到老版本数据，需要顺着 undo 链找到满足其可见性的记录。

undo log 主要分为两种：insert undo log 和 update undo log。其中 insert undo log 事务对 insert 操作产生的 undo log，只在事务回滚时需要，并且在事务提交后就可以立即丢弃。update undo log 不仅在事务回滚时需要，快照读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的 undo log 才会被 purge 线程删除。

日志的工作方式：

TODO

![image-20210818021950767](https://z3.ax1x.com/2021/08/18/fIYD6e.png)



![image-20210818022025426](https://z3.ax1x.com/2021/08/18/fIYBlD.png)

**（3）read view**

read view 主要用来做可见性判断，即当我们执行快照读会针对我们查询的数据创建出一个 read view，来决定当前事务能看到哪个版本的数据。有可能是当前最新版本的数据，也有可能是 undo log 中某个版本的数据。

read view 遵循一个可见性算法，主要是讲要修改的数据的 DB_TRX_ID 取出来，与系统其他活跃事务 id 做对比，如果大于等于这些活跃事务 id，就通过 DB_ROLL_PTR 指针去取出 undo log 上一层的 DB_TRX_ID，直到小于这些活跃事务 id 为止，这样就保证了我们的数据版本是当前可见的最稳定的版本。



undo log 工作方式还没记录





# 四、语法

# 五、理论范式