[TOC]

# 二叉树天然的递归结构（二叉树的最大深度）

## 问题分析

二叉树是天然的递归结构，它的左子树也是二叉树，右子树也是二叉树，并且没有递归终止条件，并且空也是二叉树。

> [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #389e0d;background: #f6ffed;border-color: #b7eb8f;">简单</span>
>
> 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

1. 深度优先遍历（递归）

   ```java
   /**
    * 深度优先遍历（递归）
    * 时间复杂度: O(n)
    * 空间复杂度: O(height)
    */
   class Solution {
       public int maxDepth(TreeNode root) {
           if (root == null) 
               return 0;
           return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
       }
   }
   ```

2. 广度优先遍历（队列）

   ```java
   /**
    * 广度优先遍历（队列）
    * 时间复杂度: O(n)
    * 空间复杂度: 取决于队列中存储的元素，最坏 O(n)
    */
   class Solution2 {
       public int maxDepth(TreeNode root) {
           if (root == null) return 0;
           
           Queue<TreeNode> queue = new LinkedList<>();
           queue.offer(root);
           int depth = 0;
           while (!queue.isEmpty()) {
               int size = queue.size();
               for (int i = 0; i < size; i++) {
                   TreeNode node = queue.poll();
                   if (node.left != null) queue.offer(node.left);
                   if (node.right != null) queue.offer(node.right);
               }
               depth++;
           }
           return depth;
       }
   }
   ```

## 相关问题

> [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #389e0d;background: #f6ffed;border-color: #b7eb8f;">简单</span>
>
> 给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

1. 深度优先遍历

   ```java
   /**
    * 深度优先遍历
    * 时间复杂度: O(N)
    * 空间复杂度: O(H)，平均情况下为 O(logN)
    */
   class Solution {
       public int minDepth(TreeNode root) {
           if (root == null) {
               return 0;
           } else if (root.left == null) {
               return minDepth(root.right) + 1;
           } else if (root.right == null) {
               return minDepth(root.left) + 1;
           } else {
               return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
           }
       }
   }
   ```

2. 广度优先遍历

   ```java
   /**
    * 广度优先遍历
    * 时间复杂度: O(N)
    * 空间复杂度: O(N)
    */
   class Solution {
       public int minDepth(TreeNode root) {
           if (root == null) return 0;
           
           Queue<TreeNode> queue = new LinkedList<>();
           queue.offer(root);
           int minDepth = 0;
           while (!queue.isEmpty()) {
               int size = queue.size();
               for (int i = 0; i < size; i++) {
                   TreeNode node = queue.poll();
                   if (node.left == null && node.right == null) {
                       return minDepth + 1;
                   }
                   if (node.left != null) queue.offer(node.left);
                   if (node.right != null) queue.offer(node.right);
               }
               minDepth++;
           }
   
           return 0;
       }
   }
   ```

# 一个简单的二叉树问题引发的血案（翻转二叉树）

## 问题分析

> [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #389e0d;background: #f6ffed;border-color: #b7eb8f;">简单</span>
>
> 翻转一棵二叉树。

```java
/**
 * 递归翻转二叉树
 * 时间复杂度: O(n)
 * 空间复杂度: O(n)
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null)
            return root;

        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        root.left = right;
        root.right = left;
        return root;
    }
}
```

## 相关问题

> [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #389e0d;background: #f6ffed;border-color: #b7eb8f;">简单</span>
>
> 给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。
>
> 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

1. 深度优先搜索

   ```java
   /**
    * 深度优先搜索
    * 时间复杂度: O(min(m, n)), 其中 m 和 n 分别是两个二叉树的节点数。
    * 空间复杂度: O(min(m, n))
    */
   class Solution {
       public boolean isSameTree(TreeNode p, TreeNode q) {
           if (p == null && q == null) {
               return true;
           } else if (p == null || q == null || p.val != q.val) {
               return false;
           } else {
               return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
           }
       }
   }
   ```

2. 广度优先搜索

   ```java
   /**
    * 广度优先搜索
    * 时间复杂度: O(min(m, n)), 其中 m 和 n 分别是两个二叉树的节点数。
    * 空间复杂度: O(min(m, n))
    */
   class Solution {
       public boolean isSameTree(TreeNode p, TreeNode q) {
           if (p == null && q == null)
               return true;
           else if (p == null || q == null || p.val != q.val)
               return false;
   
           Queue<TreeNode> queue1 = new LinkedList<>();
           Queue<TreeNode> queue2 = new LinkedList<>();
           queue1.offer(p);
           queue2.offer(q);
           while (!queue1.isEmpty() || !queue2.isEmpty()) {
               TreeNode node1 = queue1.poll();
               TreeNode node2 = queue2.poll();
               if (node1.val != node2.val)
                   return false;
               TreeNode left1 = node1.left, left2 = node2.left, right1 = node1.right, right2 = node2.right;
               // 异或运算，判断空值情况
               if (left1 == null ^ left2 == null || right1 == null ^ right2 == null)
                   return false;
               if (left1 != null) {
                   queue1.offer(left1);
                   queue2.offer(left2);    // 经过异或判断，left2 != null 也成立
               }
               if (right2 != null) {
                   queue1.offer(right1);
                   queue2.offer(right2);   // 经过异或判断，right2 != null 也成立
               }
           }
           return queue1.isEmpty() && queue2.isEmpty();
       }
   }
   ```

> [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #389e0d;background: #f6ffed;border-color: #b7eb8f;">简单</span>
>
> 给定一个二叉树，检查它是否是镜像对称的。

1. 递归

   ```java
   /**
    * 递归
    * 时间复杂度: O(n)
    * 空间复杂度: O(n)
    */
   class Solution {
       public boolean isSymmetric(TreeNode root) {
           return check(root, root);
       }
   
       private boolean check(TreeNode p, TreeNode q) {
           if (p == null && q == null)
               return true;    // 同时为空 true
           else if (p == null || q == null)
               return false;   // 一方为空 fasle
           else if (p.val != q.val)
               return false;   // 值不相等 false
           else
               return check(p.left, q.right) && check(p.right, q.left);  // 递归检查对称性
       }
   }
   ```

2. 广度优先搜索

   ```java
   /**
    * 广度优先遍历
    * 时间复杂度: O(n)
    * 空间复杂度: O(n)
    */
   class Solution2 {
       public boolean isSymmetric(TreeNode root) {
           if (root == null) 
               return true;
           else if (root.left == null && root.right == null)
               return true;
           else if (root.left == null || root.right == null)
               return false;
   
           Deque<TreeNode> deque = new LinkedList<>();
           deque.addFirst(root.left);
           deque.addLast(root.right);
           while (!deque.isEmpty()) {
               Deque<TreeNode> nextDeque = new LinkedList<>();  // 存放下一层的节点
               int currentLevelSize = deque.size();
               for (int i = 0; i < currentLevelSize; i = i + 2) {
                   // 每次出队首位两个，进行对比
                   TreeNode p = deque.removeFirst();
                   TreeNode q = deque.removeLast();
                   // 检查值是否对称
                   if (p.val != q.val)
                       return false;
                   // 检查 p、q 的子节点 null 是否对称
                   if (p.left == null ^ q.right == null || p.right == null ^ q.left == null)
                       return false;
                   // 存放下一层节点
                   if (p.left != null) {
                       nextDeque.addFirst(p.left);
                       nextDeque.addLast(q.right);
                   }
                   if (p.right != null) {
                       nextDeque.addFirst(p.right);
                       nextDeque.addLast(q.left);
                   }
               }
               deque = nextDeque;
           }
           return true;
       }
   }
   ```

> [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #d46b08;background: #fff7e6;border-color: #ffd591;">中等</span>
>
> 给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。
>
> [完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。
>
> **进阶：**遍历树来统计节点是一种时间复杂度为 `O(n)` 的简单解决方案。你可以设计一个更快的算法吗？

```java
/**
 * 判断左右子树是否满二叉树，直接计算满子树，递归计算不满的子树
 * 时间复杂度: O((logN)^2)
 * 空间复杂度: O(1)
 */
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) return 0;

        // 计算左右子树高度
        int depth1 = depth(root.left);
        int depth2 = depth(root.right);
        // 左右子树节点个数
        int count1, count2;

        // 如果左右子树高度相等，则左子树一定是满二叉树，可直接计算左子树个数，递归计算右子树
        // 否则，右子树是满二叉树，直接计算右子树个数，递归计算左子树
        if (depth1 == depth2) {
            count1 = (1 << depth1) - 1;     // 左子树满
            count2 = countNodes(root.right);
        } else {
            count1 = countNodes(root.left);
            count2 = (1 << depth2) - 1;     // 右子树满
        }
        
        // 左右子树节点个数 + 根节点 1 个
        return count1 + count2 + 1;
    }

    // 计算二叉树的高度，即统计左链节点个数
    private int depth(TreeNode root) {
        int depth = 0;
        while (root != null) {
            root = root.left;
            depth++;
        }
        return depth;
    }
}
```

> [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)
>
> 给定一个二叉树，判断它是否是高度平衡的二叉树。
>
> 平衡二叉树：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
>



# 注意递归的终止条件（路径总和）

## 问题分析

对于递归函数很重要的一点就是找到递归终止条件，这里看一个终止条件稍微复杂的题目。

> [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #389e0d;background: #f6ffed;border-color: #b7eb8f;">简单</span>
>
> 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` ，判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。

1. 深度优先遍历（递归）

   这道题适用递归的思想很简单，递归结构为在根节点 `root` 中查找左右孩子查找是否有 `sum - root.val` 的路径。

   ```java
   /**
    * 递归
    * 时间复杂度: O(n)
    * 空间复杂度: O(h)，最坏链条 O(n)，平均 O(logn)
    */
   class Solution {
       public boolean hasPathSum(TreeNode root, int targetSum) {
           if (root == null)
               return false;
           // 判断是不是叶子节点
           if (root.left == null && root.right == null) {
               return targetSum == root.val;
           } else {
               return hasPathSum(root.left, targetSum - root.val)
                       || hasPathSum(root.right, targetSum - root.val);
           }
       }
   }
   ```

2. 广度优先遍历

   ```java
   /**
    * 广度优先遍历
    * 时间复杂度: O(n)
    * 空间复杂度: O(n)
    */
   class Solution {
       public boolean hasPathSum(TreeNode root, int targetSum) {
           if (root == null) return false;
   
           Queue<TreeNode> queNode = new LinkedList<>();   // 存节点
           Queue<Integer> queVal = new LinkedList<>();     // 存到对应节点经过的路径和
           queNode.offer(root);
           queVal.offer(root.val);
           while (!queNode.isEmpty()) {
               TreeNode node = queNode.poll(); // 达到的节点
               int value = queVal.poll();      // 到达该节点经过的路径和
               // 如果到叶子节点了，判断经过的路径和
               if (node.left == null && node.right == null) {
                   if (value == targetSum)
                       return true;
                   continue;
               }
               // 没到达叶子节点，存入子节点，和到达子节点经过的路径和
               if (node.left != null) {
                   queNode.offer(node.left);
                   queVal.offer(value + node.left.val);
               }
               if (node.right != null) {
                   queNode.offer(node.right);
                   queVal.offer(value + node.right.val);
               }
           }
           return false;
       }
   }
   ```

## 相关题目

> [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)<span style="padding: 0 7px;margin: 0 7px;border: 1px solid #d9d9d9;border-radius: 2px;color: #389e0d;background: #f6ffed;border-color: #b7eb8f;">简单</span>
>
> 计算给定二叉树的所有左叶子之和。

1. 深度优先遍历

   ```java
   /**
    * 深度优先遍历
    * 时间复杂度: O(n)
    * 空间复杂度: O(n)
    */
   class Solution {
       public int sumOfLeftLeaves(TreeNode root) {
           if (root == null) return 0;
           
           int res = 0;
           // 如果左子树的叶子节点，加上 value，否则加上左子树中左边叶节点的和
           res += isLeafNode(root.left) ? root.left.val : sumOfLeftLeaves(root.left);
           // 如果右子树是叶子节点，不用加，否则加上右子树中左边叶节点的和
           res += isLeafNode(root.right) ? 0 : sumOfLeftLeaves(root.right);
           return res;
       }
   
       // 判断是不是叶子节点
       private boolean isLeafNode(TreeNode node) {
           return node != null && node.left == null && node.right == null;
       }
   }
   ```

2. 广度优先遍历

   ```java
   /**
    * 广度优先遍历
    * 时间复杂度: O(n)
    * 空间复杂度: O(n)
    */
   class Solution {
       public int sumOfLeftLeaves(TreeNode root) {
           if (root == null) return 0;
           
           int res = 0;
           Queue<TreeNode> queue = new LinkedList<>();
           queue.offer(root);
           while (!queue.isEmpty()) {
               TreeNode node = queue.poll();
               // 考察左子树，如果是叶子节点，累计 value，否则入队待考察
               if (node.left != null) {
                   if (isLeafNode(node.left)) {
                       res += node.left.val;
                   } else {
                       queue.offer(node.left);
                   }
               }
               // 考察右子树，只有不是叶子节点的时候才入队待考察
               if (node.right != null && !isLeafNode(node.right)) {
                   queue.offer(node.right);
               }
           }
   
           return res;
       }
   
       // 判断是不是叶子节点
       private boolean isLeafNode(TreeNode node) {
           return node.left == null && node.right == null;
       }
   }
   ```

# 定义递归问题（二叉树的所有路径）

前面递归相关题目的逻辑部分都很简单，这一节来看一下逻辑略微复杂一些的题目。在这个问题中大家也可以体会下如何利用递归函数的返回值。

> [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)
>
> 给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。
>
> ![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)
>
> **输入：**root = [1, 2, 3, null, 5]  **输出：**["1->2->5", "1->3"]

这个问题的递归结构也很简单，我们要找从 `root` 出发的所有路径，只需要找到左右子树的所有路径，然后前面加上 `root.val->` ，并合并两组路径即可。这里我们要注意递归终止条件是到达了叶子节点就返回路径，递归的返回值是 **路径数组**。

1. 深度优先遍历（递归）

   这道题适用递归的思想很简单，递归结构为在根节点 `root` 中查找左右孩子查找是否有 `sum - root.val` 的路径。

   ```java
   /**
    * 深优先限遍历（递归）
    * 时间复杂度: O(n), n为树中的节点个数
    * 空间复杂度: O(h), h为树的高度
    */
   class Solution {
       public List<String> binaryTreePaths(TreeNode root) {
           // 存放从本节点 root，到所有叶子节点的路径
           List<String> paths = new ArrayList<>();
           
           // 如果是 null，递归结束
           if (root == null) 
               return paths;
           // 如果是叶子节点，递归结束
           if (root.left == null && root.right == null) {
               paths.add(String.valueOf(root.val));
               return paths;
           }
           
           // 获取左孩子到叶子节点的所有路径
           List<String> leftPaths = binaryTreePaths(root.left);
           // 获取右孩子到所有叶子节点的路径
           List<String> rightPaths = binaryTreePaths(root.right);
           // 左右孩子的路径前面加上 root，就是 root 到所有叶子节点的路径
           for (String leftPath : leftPaths)
               paths.add(root.val + "->" + leftPath);
           for (String rightPath : rightPaths)
               paths.add(root.val + "->" + rightPath);
   
           return paths;
       }
   }
   ```

2. 广度优先遍历

   ```java
   /**
    * 广度优先遍历
    * 时间复杂度: O(n)
    * 空间复杂度: O(n)
    */
   class Solution2 {
       public List<String> binaryTreePaths(TreeNode root) {
           List<String> paths = new ArrayList<>();
           if (root == null) return paths;
   
           Queue<TreeNode> queNode = new LinkedList<>();
           Queue<String> quePath = new LinkedList<>();
           queNode.offer(root);
           quePath.offer(String.valueOf(root.val));
   
           while (!queNode.isEmpty()) {
               TreeNode node = queNode.poll();
               String path = quePath.poll();
               if (node.left == null && node.right == null)
                   paths.add(path);
   
               if (node.left != null) {
                   queNode.offer(node.left);
                   quePath.offer(path + "->" + node.left.val);
               }
               if (node.right != null) {
                   queNode.offer(node.right);
                   quePath.offer(path + "->" + node.right.val);
               }
           }
   
           return paths;
       }
   }
   ```

## 相关问题

> [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)
>
> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。
>
> ```
> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 
> 输出：[[5,4,11,2],[5,8,4,5]]
> ```



> [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)
>
> 给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。
>
> 每条从根节点到叶节点的路径都代表一个数字：
>
> - 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。
>
> 计算从根节点到叶节点生成的 **所有数字之和** 。
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)
>
> ```
> 输入：root = [1,2,3]
> 输出：25
> ```

 

# 复杂的递归逻辑（路径总和 III）

> [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)
>
> 给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。
>
> **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
>
> <img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
> 输出：3
> 解释：和等于 8 的路径有 3 条，如图所示。
> ```

之前递归求节点路径的时候，默认当前根节点在路径上，然后在左右孩子中找和为 `targetSum-root.val` 的路径。本题递归有两种情况，一种当前节点在路径上，和上述过程一样；一种当前节点不在路径上，在左右孩子中找和为 `targetSum` 的路径。如下图所示。

![image-20210902091126196](https://z3.ax1x.com/2021/09/02/hD3AJA.png)



```java
/**
 * 双递归
 * 时间复杂度: O(n)
 * 空间复杂度: O(h)
 */
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if (root == null)
            return 0;
        
        // 包含当前节点的结果
        int res = findPath(root, targetSum);
        // 不包含当前节点的结果
        res += pathSum(root.left, targetSum) + pathSum(root.right, targetSum);

        return res;
    }
    
    /**
     * 在 root 为跟的二叉树中，寻找包含 root 的路径，和为 sum
     * @param root      二叉树根节点
     * @param targetSum 路径和
     * @return 返回这样的路径个数
     */
    private int findPath(TreeNode root, int targetSum) {
        if (root == null) 
            return 0;
        
        int res = 0;
        if (targetSum == root.val) 
            res += 1;
        res += findPath(root.left, targetSum - root.val);
        res += findPath(root.right, targetSum - root.val);
        return res;
    }
}
```

由于没有规定路径一定要到叶子节点，并且节点值可能有负数，所以逻辑上比之前的 [112. 路径总和](https://leetcode-cn.com/problems/path-sum/) 和 [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/) 复杂不少，不过思路大致相同。

# 二分搜索树中的问题（二叉搜索树的最近公共祖先）

二分搜索树：每个节点的键值大于左孩子;每个节点的键值小于右孩子;以左右孩子为根的子树仍为二分搜索树。

二分搜索树是二叉树的一种，请大家复习二分搜索树的基本操作：

- 插入 insert
- 查找 find
- 删除 delete
- 最大值，最小值 minimum, maximum
- 前驱，后继 successor，predecessor
- 上界，下界 floor，ceil
- 某个元素的排名 rank
- 寻找第 k 大(小)元素 select

由于二分搜索树的结构特点，以上操作的时间复杂度都是 O(logN) 的。

## 问题分析

> [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
>
> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
>
> 最近公共祖先的定义为：对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。

对于根节点 root，我们可以分析输出以下递归结构：

- 如果 p 和 q 都小于 root，则去 root 的左侧找它们的最近公共祖先
- 如果 p 和 q 都大于 root，则去 root 的右侧找它们的最近公共祖先
- 如果 p 和 q 在 root 的两边，则 root 就是它们的最近公共祖先
- 如果 p 和 q 其中之一等于 root，那它就是最近公共祖先

1. 递归

   ```java
   /**
    * 递归
    * 时间复杂度: O(logN)
    * 空间复杂度: O(h)
    */
   class Solution {
       public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
           if (p == null || q == null)
               throw new IllegalStateException("error state");
           if(root == null)
               return null;
           
           if (p.val < root.val && q.val < root.val)
               return lowestCommonAncestor(root.left, p, q);
           if (p.val > root.val && q.val > root.val)
               return lowestCommonAncestor(root.right, p, q);
           return root;
       }
   }
   ```

2. 迭代

   ```java
   /**
    * 迭代
    * 时间复杂度: O(n)
    * 空间复杂度: O(1)
    */
   class Solution {
       public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
           while (true) {
               if (p.val < root.val && q.val < root.val) {
                   root = root.left;
               } else if (p.val > root.val && q.val > root.val) {
                   root = root.right;
               } else {
                   break;
               }
           }
           return root;
       }
   }
   ```

## 相关问题

> [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)
>
> 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
>
> 假设一个二叉搜索树具有如下特征：
>
> - 节点的左子树只包含**小于**当前节点的数。
> - 节点的右子树只包含**大于**当前节点的数。
> - 所有左子树和右子树自身必须也是二叉搜索树。



> [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)
>
> 给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
>
> 一般来说，删除节点可分为两个步骤：
>
> 1. 首先找到需要删除的节点；
> 2. 如果找到了，删除它。
>
> **说明：** 要求算法时间复杂度为 O(h)，h 为树的高度。



> [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)
>
> 给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。
>
> **高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。



> [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)
>
> 给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。



> [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
>
> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
> 最近公共祖先：对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。